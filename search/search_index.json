{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Literate Programming with Entangled, Gitpod and MkDocs \u00b6 This repository is a template to create beautiful literate programs with Entangled and Mkdocs. In order to make it easier to start writing your documentation this also runs as a Gitpod instance. So you only need to fork this repository and open it on gitpod: https://gitpod.io/#prebuild/ And you can start write your documentation right away. Now this is also a literate programming environment. Using https://entangled.github.io. That means that code fragments you write in your makrdown files get extracted automatically and exposed as files. Take a look at 'docs/index.md' to learn how the dockerfile that allows this project to be executed in GitPod get's generated. And the continuous integration github action.","title":"Home"},{"location":"#literate-programming-with-entangled-gitpod-and-mkdocs","text":"This repository is a template to create beautiful literate programs with Entangled and Mkdocs. In order to make it easier to start writing your documentation this also runs as a Gitpod instance. So you only need to fork this repository and open it on gitpod: https://gitpod.io/#prebuild/ And you can start write your documentation right away. Now this is also a literate programming environment. Using https://entangled.github.io. That means that code fragments you write in your makrdown files get extracted automatically and exposed as files. Take a look at 'docs/index.md' to learn how the dockerfile that allows this project to be executed in GitPod get's generated. And the continuous integration github action.","title":"Literate Programming with Entangled, Gitpod and MkDocs"},{"location":"06-Plutus-transactions/","text":"This tutorial outlines what a Plutus transaction is and how to write one. This is done in the follow sequence: Write your Plutus on chain code. Serialize your Plutus on chain code to the text envelope format ( cardano-cli expects this format). Create your transaction with the accompanying Plutus script(s). Submit the transaction to execute Plutus script. What is a Plutus transaction \u00b6 A transaction is a piece of data that contains both inputs and outputs, and as of the Alonzo era, they can also include Plutus scripts. Inputs are unspent outputs from previous transactions (UTxO). As soon as an UTxO is used as input in a transaction, it becomes spent and can never be used again. The output is specified by an address (a public key or public key hash) and a value (consisting of an ADA amount and optional additional native token amounts). This flow-diagram gives a better idea of what the components of a transaction are at a technical level: In short, inputs contain references to UTXOs introduced by previous transactions, and outputs are the new UTXOs that this transaction will produce. Also, if we think about it, this allows us to change the state of a smart contract since new data can be contained in the produced outputs. It is also important to define what Plutus Tx is. Plutus Tx is the name given to specially-delimited sections of a Haskell program that are used to compile the on-chain part of a contract application into Plutus Core (this compiled code is then used for validating a transaction, hence the \"Tx\"). The resulting Plutus Core expression can be part of transaction data or data stored on the ledger. These pieces of code require special processing on the blockchain and are referred to as Plutus script . Why \u00b6 From a Plutus developer perspective, by using transactions, we can control the flow of execution of our Plutus script. Thus, a transaction can also be thought of as messages used to interact with the smart contract. Understanding transactions is a key concept to master the development of smart contracts. When \u00b6 A transaction ought to be created by the wallet while evaluating the off-chain code. For now, we have to assemble the transaction using cardano-cli and place the compiled Plutus script inside. At later stages though, this will be automated by the user's wallet software. The transaction, once submitted, will be validated and, therefore, the Plutus code will be evaluated by a validator node. If the script evaluates successfully, the transaction will be considered as valid. If not, the transaction will be rejected. Setting up the environment \u00b6 If you already have a Haskell development environment set up, feel free to skip this section, otherwise follow along, we will set up a suitable environment for compiling plutus scripts using Nix, alternatively, you can follow this guide . We will use Nix to provide both Haskell and Cabal, but if you desire, you could also rely on the ghcup tool to manage these dependencies. However, we won't cover this. You can refer to the official ghcup site for instructions on that approach. Nix is an amazing tool that, among other things, allows us to create isolated environments in which we can embed all dependencies needed for an application. These dependencies can even be system-level dependencies. Thus, we can create an isolated environment to ensure the application will work since all required dependencies are available. Install Nix on any Linux distribution , MacOS or Windows (via WSL) via the recommended multi-user installation . In short, you need to run this at your terminal: #install-nix # sh <(curl -L https://nixos.org/nix/install) --daemon To improve build speed, it is highly suggested to set up a binary cache maintained by IOHK by doing the following: #setup-binary-cache sudo mkdir -p /etc/nix cat <<EOF | sudo tee /etc/nix/nix.conf substituters = https://cache.nixos.org https://hydra.iohk.io trusted-public-keys = iohk.cachix.org-1:DpRUyj7h7V830dp/i6Nti+NEO2/nhblbov/8MW7Rqoo= hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ= cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= EOF Before Nix works in your existing shells, you need to close them and open them again. Other than that, you should be ready to go. Once Nix is installed, log out and then log back in, so it is activated properly in your shell. Clone the following and check out the latest version of the node. Please refer to the cardano-node releases page to ensure you are working with the latest version of this. #install-cardano-node git clone --depth 1 https://github.com/input-output-hk/cardano-node cd cardano-node git fetch --all --recurse-submodules --tags #latesttag=$(git describe --tags) #git checkout tags/$latesttag git checkout tags/1.29.0 Create a file in the root of the git repository we just cloned and save it as plutus-tutorial.nix : file://tutorials/plutus/plutus-tutorial.nix { version ? \"mainnet\" , pkgs ? import ( fetchTarball \"https://github.com/NixOS/nixpkgs/archive/6525bbc06a39f26750ad8ee0d40000ddfdc24acb.tar.gz\" ) { }}: let cardano-node-repo = import . /. { }; in pkgs . mkShell { buildInputs = with pkgs ; [ libsodium cabal-install zlib haskell . compiler . ghc8104 haskellPackages . haskell-language-server cardano-node-repo . scripts . \" ${ version } \" . node cardano-node-repo . cardano-cli ]; CARDANO_NODE_SOCKET_PATH = \" ${ builtins . toString . /. } /state-node- ${ version } /node.socket\" ; } and then load a shell with Nix using this file with the following command: #start-nix-shell nix-shell ./plutus-tutorial.nix This will take approximately five or ten minutes the first time you do it, you should see something similar to this: these paths will be fetched ( 445 .08 MiB download, 5870 .53 MiB unpacked ) : /nix/store/04jc7s1006vhg3qj4fszg6bcljlyap1a-conduit-parse-0.2.1.0-doc /nix/store/052kzx9p5fl52pk436i2jcsqkz3ni0r2-reflection-2.1.6-doc . . . /nix/store/7jq1vjy58nj8rjwa688l5x7dyzr55d9f-monad-memo-0.5.3... ( 34 KB left ) This creates an environment with all dependencies listed in the \u201cbuildInputs\u201d section, with GHC 8.10.4 and Cabal among these. Once you have recent versions of GHC and Cabal, make sure to use GHC 8.10.2 or later: #verify-ghc-version ghc --version cabal --version Running the cardano-node \u00b6 Inside the nix-shell start a passive Cardano node, remember to first activate the Nix environment if you have not done so: nix-shell plutus-tutorial.nix ** [ nix-shell:~ ] ** #start-passive-cardano-node cardano-node-mainnet At this point, the node will start syncing with the network, which will come useful for submitting our transactions later. We are now ready to start building the Plutus transaction. Keep the node running in this shell, and open a new terminal to continue with the following steps. Remember to enter the nix-shell environment in this new terminal so you have both GHC and Cabal available. Ensure that you have the latest tagged version era \u00b6 In a new terminal, i.e. the cardano node should still be running in the old terminal. #ensure-you-are-in-alonzo cardano-cli query tip ${ NETWORK_ID } You should now see the following: { \"epoch\" : 155 , \"hash\" : \"c8ae0bb7f06743cd95c35e19c866a811b7a3f104ad362c8667b9f0a1f0907ed2\" , \"slot\" : 36882965 , \"block\" : 2899736 , \"era\" : \"Alonzo\" , \"syncProgress\" : \"100.00\" } Note: Ensure that \u201cera\u201d corresponds to \u201cAlonzo\u201d. If you have just started the node, you might need to wait for your node to sync before you can see this. The node is not actually needed to build a transaction, but it is useful to submit the transaction to the network. Generating Wallets \u00b6 We must first create a payment key-pair and a wallet address if you haven't already. For this example, we need to generate two addresses as follows. For this step, generate a payment key in the corresponding address: #generate-wallets cardano-cli address key-gen \\ --verification-key-file ./temp/ $OWNER .vkey \\ --signing-key-file ./temp/ $OWNER .skey cardano-cli stake-address key-gen \\ --verification-key-file ./temp/ $OWNER .stake.vkey \\ --signing-key-file ./temp/ $OWNER .stake.skey cardano-cli address build \\ --payment-verification-key-file ./temp/ $OWNER .vkey \\ --stake-verification-key-file ./temp/ $OWNER .stake.vkey \\ --out-file ./temp/ $OWNER .addr \\ $NETWORK_ID #generate-wallets Make sure to generate an additional wallet using the same steps above, so you can test transactions between these addresses. Build and submit a simple (non-Plutus) transaction \u00b6 In this simple transaction, we send funds from one personal address to another address. Assume that we have these addresses in payment.addr and payment2.addr files and we want to send 500 ADA from the first address to the second address. First, we need to query the UTXOs in the payment.addr : #verify-payment-address-has-funds cardano-cli query utxo --address ${ ALICE_ADDR } $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- 8c6f74370d823130847efe3d2e2e128f0e79c8e907fda692353d841dd0d6cb38 0 1000000000 lovelace + TxOutDatumHashNone #read-utxo-to-variable readonly UTXO_TXIX = $( cardano-cli query utxo $NETWORK_ID --address $ALICE_ADDR | select_utxo_with_most_value ) echo echo \"UTxO: $UTXO_TXIX \" Using this information, we can build a transaction: #build-transaction cardano-cli transaction build \\ --alonzo-era \\ $NETWORK_ID \\ --change-address ${ ALICE_ADDR } \\ --tx-in ${ UTXO_TXIX } \\ --tx-out $( cat ./temp/bob.addr ) +5000000 \\ --out-file ./temp/tx.build In the --tx-in argument we set the UTXO that we are using as input, the format of which is TxHash#TxIx. The --tx-out argument determines the output of the new UTXOs, the format of which is address+amount. As seen in the flow-diagram above, we can have one or more inputs and outputs. What follows is to sign and submit the transaction: #sign-simple-transaction cardano-cli transaction sign \\ --tx-body-file ./temp/tx.build \\ $NETWORK_ID \\ --signing-key-file ./temp/alice.skey \\ --out-file ./temp/tx.signed #submit-simple-transaction cardano-cli transaction submit --tx-file ./temp/tx.signed $NETWORK_ID Transaction successfully submitted. Now if we query payment2.addr we will have a new UTxO containing 500 ADAs: #query-2nd-address cardano-cli query utxo --address $( cat ./temp/bob.addr ) $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- d7d207438c90fe611c1a14be29974b1662f8563331bf6fba4b6569e089ffa561 1 500000000 lovelace + TxOutDatumHashNone #query-1st-address cardano-cli query utxo --address ${ ALICE_ADDR } $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- d7d207438c90fe611c1a14be29974b1662f8563331bf6fba4b6569e089ffa561 0 499831815 lovelace + TxOutDatumHashNone We have now sent a simple transaction. Write your Plutus on chain code \u00b6 We need a Haskell program to compile our desired Plutus script. In this example we will use the plutus-alwayssucceeds Plutus script. Note The \u201cPlutus always succeeds\u201d script is used in this tutorial only as an example , as it uses a very simple protection mechanism that does not perform any validation of funds. Therefore, we recommend that you do not deploy this contract on the mainnet. If you still want to deploy it on mainnet, you should use a more secure datum. #clone-plutus-alwayssucceeds git clone https://github.com/input-output-hk/Alonzo-testnet.git cd Alonzo-testnet/resources/plutus-sources/plutus-alwayssucceeds Note that, even though the program is part of the testnet examples, it will work for us on mainnet just fine. Serialize your Plutus on chain code \u00b6 By building the project, we generate a binary that compiles this script. #serialize-on-chain-code cabal update cabal build Execute the plutus-alwayssucceeds project \u00b6 We will pick a random number. It will be passed as an argument to the Plutus script (it is not used by the script right now, but will be required by transactions using the script). The second argument is the filename we want for the compiled Plutus script. #execute-alwayssucceeds cabal run plutus-alwayssucceeds -- 42 alwayssucceeds.plutus You should see something like this: Up to date Writing output to: alwayssucceeds.plutus \"Log output\" [] \"Ex Budget\" ExBudget { exBudgetCPU = ExCPU 297830 , exBudgetMemory = ExMemory 1100 } #print-serialized-alwayssucceeds cat alwayssucceeds.plutus You should see something like this: { \"type\" : \"PlutusScriptV1\" , \"description\" : \"\" , \"cborHex\" : \"4e4d01000033222220051200120011\" } We will then have the Plutus script compiled. Now, we need to build the transaction, using the cardano-cli project including the Plutus script. Transaction to lock funds \u00b6 A transaction to lock funds is very similar to a simple transaction. However, it has two key differences: we lock funds to a script address instead of a common one, and we need to specify a datum hash for every output. We use the plutus-alwayssucceeds Plutus validator script that we compiled earlier. This script will not check anything and will always succeed regardless of the value of the datum and redeemer. {-# INLINABLE mkValidator #-} mkValidator :: Data -> Data -> Data -> () mkValidator _ _ _ = () First, calculate the script address: #calculate-script-address cardano-cli address build \\ --payment-script-file ./temp/alwayssucceeds.plutus \\ $NETWORK_ID \\ --out-file ./temp/script.addr Now the script address is in the script.addr file: #calculate-script-address cat ./temp/script.addr We do not attach the datum to a UTXO directly but we use its hash. To get the hash of the datum, run the following cardano-cli command: #get-datum-hash export SCRIPTDATUMHASH = $( cardano-cli transaction hash-script-data --script-data-value 42 ) Next, get the protocol parameters and save them to a file named pparams.json using: #get-protocol-parameters cardano-cli query protocol-parameters \\ $NETWORK_ID \\ --out-file ./temp/pparams.json Now, we should build the transaction that will send ADA to the script address of our plutus-alwayssucceeds script. We write the transaction in a file called tx-script.build : #build-transaction-to-alwayssucceeds cardano-cli transaction build \\ --alonzo-era \\ $NETWORK_ID \\ --change-address ${ ALICE_ADDR } \\ --tx-in \" $UTXO_TXIX \" \\ --tx-out $( cat ./temp/script.addr ) +1379280 \\ --tx-out-datum-hash ${ SCRIPTDATUMHASH } \\ --protocol-params-file ./temp/pparams.json \\ --out-file ./temp/tx-script.build Continue to sign the transaction with the signing key payment.skey and save this signed transaction in a file tx-script.signed : #sign-transaction-to-alwayssucceeds cardano-cli transaction sign \\ --tx-body-file ./temp/tx-script.build \\ --signing-key-file ./temp/alice.skey \\ $NETWORK_ID \\ --out-file ./temp/tx-script.signed Finally, submit the transaction: #submit-transaction-to-alwayssucceeds cardano-cli transaction submit $NETWORK_ID --tx-file ./temp/tx-script.signed Transaction successfully submitted. We can query both personal and script addresses: #query-personal-and-script-addresses cardano-cli query utxo --address ${ ALICE_ADDR } $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- f5a618d579bc66e6199ae2a1ab4a73e2d8a73cba61a324c939346e9cf32bb33a 0 498284086 lovelace + TxOutDatumHashNone #get-script-address-balance export SCRIPT_ADDR = $( cat ./temp/script.addr ) cardano-cli query utxo --address $SCRIPT_ADDR $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- f5a618d579bc66e6199ae2a1ab4a73e2d8a73cba61a324c939346e9cf32bb33a 1 1379280 lovelace + TxOutDatumHash ScriptDataInAlonzoEra \"7c7c0bf83e0ed45faf3976a5ee19b4ef8bd069baab4275425161ac89d492bf82\" . . #plutusUtxoTxin # export PLUTUSUTXOTXIN=68a947f8ccb6845d3abf67376680509b476ea1cca187a486a93703bf59493f19#1 PLUTUSUTXOTXIN = $( cardano-cli query utxo --address $SCRIPT_ADDR $NETWORK_ID | grep \"1379280\" | tail -n1 | cut --delimiter = \" \" --output-delimiter = \"#\" -f 1 ,6 ) readonly PLUTUSUTXOTXIN Now, we have sent funds to a script. 4. Submit transaction to execute Plutus script \u00b6 To unlock funds from a script, we need the redeemer. Let\u2019s remember that this script will always succeed regardless of the value of the redeemer, so long as we provide the correct datum. So we can use any value as a redeemer. We also need an input as collateral: it covers the fees if the transaction fails. Then, we need a UTXO with enough funds. We are going to create a simple transaction using the payment2.addr account as an example. It results in two new UTXOs. Check the balances: #get-balance-2nd-address export BOB_ADDR = $( cat ./temp/bob.addr ) cardano-cli query utxo --address $BOB_ADDR $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- d7d207438c90fe611c1a14be29974b1662f8563331bf6fba4b6569e089ffa561 1 500000000 lovelace + TxOutDatumHashNone #txCollateral export txCollateral = $( cardano-cli query utxo $NETWORK_ID --address $BOB_ADDR | select_utxo_with_most_value ) echo echo \"txCollateral: $txCollateral \" Construct, sign, and submit the new transaction to unlock the funds: #build-transaction-to-unlock-funds cardano-cli transaction build \\ --alonzo-era \\ $NETWORK_ID \\ --tx-in ${ PLUTUSUTXOTXIN } \\ --tx-in-script-file ./temp/alwayssucceeds.plutus \\ --tx-in-datum-value 42 \\ --tx-in-redeemer-value 42 \\ --tx-in-collateral ${ txCollateral } \\ --change-address ${ ALICE_ADDR } \\ --protocol-params-file ./temp/pparams.json \\ --out-file ./temp/test-alonzo.tx If we use a UTXO that is part of a script address as an input of the transaction, we need to specify the --tx-in-script-file --tx-in datum-value --tx-in-redeemer-value --tx-in-collateral arguments after the --tx-in argument containing that UTXO: #sign-transaction-to-unlock-funds cardano-cli transaction sign \\ --tx-body-file ./temp/test-alonzo.tx \\ --signing-key-file ./temp/bob.skey \\ $NETWORK_ID \\ --out-file ./temp/test-alonzo.signed #submit-transaction-to-unlock-funds cardano-cli transaction submit $NETWORK_ID --tx-file ./temp/test-alonzo.signed Transaction successfully submitted. Now, if we query both addresses we can see that we have unlocked the funds: #query-both-addresses echo \"Bob address has the funds liberated\" cardano-cli query utxo --address $( cat ./temp/bob.addr ) $NETWORK_ID echo \"now the contract address has one uxto less\" cardano-cli query utxo --address $( cat ./temp/script.addr ) $NETWORK_ID | grep \"1379280\" At this point, you have successfully submitted your first Plutus transaction! Automating the tutorial \u00b6 This tutorial is composed of four sections: Installing Cardano Node with Nixos Creating wallets Submitting a simple non-plutus transaction Submitting a plutus transaction On the following scripts we are going to automate what we told the user to type Creating wallets \u00b6 file://tutorials/plutus/scripts/10_create_wallets.sh <<exe cute-in-bash-strict-mode>> #### Build and submit a simple (non-Plutus) transaction ### Ensure that you have the latest tagged version era. <<ensure-you-are-in-alonzo>> function create_wallets(){ local OWNER=$1 <<gen erate-wallets>> } create_wallets 'alice' # echo \"Calling the faucet API to get some funds for our new wallets\" # readonly APIKEY=$(cat ./secrets/api.key) # curl --insecure -v -XPOST \"https://faucet.cardano-testnet.iohkdev.io/send-money/${ALICE_ADDR}?apiKey=${APIKEY}\" ### create a 2nd address create_wallets 'bob' echo \"Wallets generated\" ### Once we have proven that the instructions to generate an address still work. # We will copy the known good adressess cp ./secrets/alice* ./temp/ cp ./secrets/bob* ./temp/ <<read-payment-address-to-variable>> <<verify-payment-address-has-funds>> <<read -utxo-to-variable>> assert_there_is_txhash $UTXO_TXIX # Now that we know that the instructions to create wallets work. # let's substitute the files, with the ones we know have funds, # so that the following tests also work. Submit a simple non Plutus transaction \u00b6 file://tutorials/plutus/scripts/20_submit_simple_transaction.sh <<exe cute-in-bash-strict-mode>> <<read-payment-address-to-variable>> <<read -utxo-to-variable>> <<build-transaction>> <<sign-simple-transaction>> <<sub mit-simple-transaction>> echo \"Awaiting Transaction to be committed...\" sleep 60 echo \"and the 2nd payment adress has 50,000,000 *more* lovelaces\" <<query-2nd-address>> echo \"and the 1st payment adress has 50,000,000 *less* lovelaces\" <<query -1st-address>> echo \"End: We were able to submit a simple transaction\" Submit a Plutus Transaction \u00b6 file://tutorials/plutus/scripts/30_submit_plutus_transaction.sh <<execute-in-bash-strict-mode>> <<ensure-you-are-in-alonzo>> <<calculate-script-address>> <<get-datum-hash>> <<get-protocol-parameters>> <<read-payment-address-to-variable>> <<read-utxo-to-variable>> <<build-transaction-to-alwayssucceeds>> <<sign-transaction-to-alwayssucceeds>> <<submit-transaction-to-alwayssucceeds>> <<query-personal-and-script-addresses>> <<get-script-address-balance>> <<ensure-you-are-in-alonzo>> <<get-script-address-balance>> #copying busybox from the test script directory to bin cp ./busybox /bin/ ln -s -T /bin/busybox /bin/grep <<plutusUtxoTxin>> ### 4. Submit transaction to execute Plutus script <<get-balance-2nd-address>> <<txCollateral>> <<build-transaction-to-unlock-funds>> <<sig n-transaction-to-unlock-funds>> <<submit-trans action-to-unlock-funds>> <<query-both-addresses>> Now what we want is to create script / program that we can automatically execute with the steps we told the user to follow. A script that looks like this: <<exe cute-in-bash-strict-mode>> <<install-nix>> <<setup-binary-cache>> <<install -cardano-node>> cp ../tutorials/plutus/plutus-tutorial.nix . Bash strict mode \u00b6 This causes bash to behave in a way that makes many classes of subtle bugs impossible. You'll spend much less time debugging, and also avoid having unexpected complications in production. For more info: http://redsymbol.net/articles/unofficial-bash-strict-mode/ #execute-in-bash-strict-mode #The shebang must be the first line of the file, but then it get's mixed with entangled comments # this script must be executed with `bash $name_of_script` #!/bin/bash set -xeEuo pipefail #IFS=$'\\n\\t' function select_utxo_with_most_value () { cut --delimiter = ' ' --fields = 14 ,1,6 --only-delimited < /dev/stdin | \\ sort --human-numeric-sort --key = 3 | cut --delimiter = ' ' --fields = 1 ,2 --output-delimiter = \"#\" | \\ tail --lines = 1 > /dev/stdout } assert_not_empty (){ [ \" $var \" ] || { echo \"Parameter 1 is empty\" ; exit 1 ; } } assert_there_is_txhash (){ local var = \" $1 \" [ ${# var } == 66 ] || { echo \"TxHash can't be empty\" ; exit 1 ; } } readonly CARDANO_NODE_SOCKET_PATH = /ipc/node.socket readonly NETWORK_ID = \"--testnet-magic 1097911063\" # or \"--mainnet\" #read-payment-address-to-variable readonly ALICE_ADDR = $( cat ./temp/alice.addr ) echo echo \"Payment address is: $ALICE_ADDR \" Inside nix-shell \u00b6 Now what we want is to create script / program that we can automatically execute with the steps we told the user to follow. A script that looks like this: <<exe cute-in-bash-strict-mode>> <<verify-ghc-ver sion>> <<start-pas sive-cardano-node>> cd cardano-node Ultra \u00b6 How to execute this tests? In order to run this tutorial we need 3 containers: Cardano-node :: that is connected to the blockchain and downloading the blocks Cardano-cli :: that sends transactions to the Cardano-node Plutus compiler:: So that you can compile the plutus script used later. And also Cardano-node and the cardano-cli must be together. So in order to do that I use docker compose architecture file://tutorials/plutus/docker-compose.yml version : '3' services : cardano-node : image : inputoutput/cardano-node volumes : - ./cardano-testnet-1097911063/_data:/data - node-ipc:/ipc environment : - NETWORK=testnet node : image : inputoutput/cardano-node volumes : - node-ipc:/ipc:ro - ./:/plutus/ tty : true stdin_open : true environment : - CARDANO_NODE_SOCKET_PATH=/ipc/node.socket command : cli profiles : - cardano depends_on : - cardano-node plutus : image : inputoutput/plutus-starter-devcontainer volumes : node-ipc : external : true Then you can execute start the architecture simply as: docker-compose up --detach --remove-orphans And then you can join the cardano-cli node like this: docker-compose run node cli query tip --testnet-magic 1097911063 Now to execute the tests: docker-compose run --entrypoint = \"/bin/bash\" node ./scripts/10_creating_wallets.sh \" docker-compose run --entrypoint=\" /bin/bash \" node ./scripts/20_submit_simple_transaction.sh\" docker-compose run --entrypoint = \"/bin/bash\" node ./scripts/30_submit_plutus_transaction.sh \" we override the default entry point here so that it waits for a script file. In order to turn off the servers run this document docker-compose down Hyper: How to run this infraestructure in GitHub actions \u00b6 TODO : everything again but with Nix \u00b6 tutorial meta: things to make the tutorial work ultra: things to setup the docker instances where the the tutorial would work (docker-compose) hyper: make the tutorial execute in CI","title":"How to write Plutus transactions"},{"location":"06-Plutus-transactions/#what-is-a-plutus-transaction","text":"A transaction is a piece of data that contains both inputs and outputs, and as of the Alonzo era, they can also include Plutus scripts. Inputs are unspent outputs from previous transactions (UTxO). As soon as an UTxO is used as input in a transaction, it becomes spent and can never be used again. The output is specified by an address (a public key or public key hash) and a value (consisting of an ADA amount and optional additional native token amounts). This flow-diagram gives a better idea of what the components of a transaction are at a technical level: In short, inputs contain references to UTXOs introduced by previous transactions, and outputs are the new UTXOs that this transaction will produce. Also, if we think about it, this allows us to change the state of a smart contract since new data can be contained in the produced outputs. It is also important to define what Plutus Tx is. Plutus Tx is the name given to specially-delimited sections of a Haskell program that are used to compile the on-chain part of a contract application into Plutus Core (this compiled code is then used for validating a transaction, hence the \"Tx\"). The resulting Plutus Core expression can be part of transaction data or data stored on the ledger. These pieces of code require special processing on the blockchain and are referred to as Plutus script .","title":"What is a Plutus transaction"},{"location":"06-Plutus-transactions/#why","text":"From a Plutus developer perspective, by using transactions, we can control the flow of execution of our Plutus script. Thus, a transaction can also be thought of as messages used to interact with the smart contract. Understanding transactions is a key concept to master the development of smart contracts.","title":"Why"},{"location":"06-Plutus-transactions/#when","text":"A transaction ought to be created by the wallet while evaluating the off-chain code. For now, we have to assemble the transaction using cardano-cli and place the compiled Plutus script inside. At later stages though, this will be automated by the user's wallet software. The transaction, once submitted, will be validated and, therefore, the Plutus code will be evaluated by a validator node. If the script evaluates successfully, the transaction will be considered as valid. If not, the transaction will be rejected.","title":"When"},{"location":"06-Plutus-transactions/#setting-up-the-environment","text":"If you already have a Haskell development environment set up, feel free to skip this section, otherwise follow along, we will set up a suitable environment for compiling plutus scripts using Nix, alternatively, you can follow this guide . We will use Nix to provide both Haskell and Cabal, but if you desire, you could also rely on the ghcup tool to manage these dependencies. However, we won't cover this. You can refer to the official ghcup site for instructions on that approach. Nix is an amazing tool that, among other things, allows us to create isolated environments in which we can embed all dependencies needed for an application. These dependencies can even be system-level dependencies. Thus, we can create an isolated environment to ensure the application will work since all required dependencies are available. Install Nix on any Linux distribution , MacOS or Windows (via WSL) via the recommended multi-user installation . In short, you need to run this at your terminal: #install-nix # sh <(curl -L https://nixos.org/nix/install) --daemon To improve build speed, it is highly suggested to set up a binary cache maintained by IOHK by doing the following: #setup-binary-cache sudo mkdir -p /etc/nix cat <<EOF | sudo tee /etc/nix/nix.conf substituters = https://cache.nixos.org https://hydra.iohk.io trusted-public-keys = iohk.cachix.org-1:DpRUyj7h7V830dp/i6Nti+NEO2/nhblbov/8MW7Rqoo= hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ= cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= EOF Before Nix works in your existing shells, you need to close them and open them again. Other than that, you should be ready to go. Once Nix is installed, log out and then log back in, so it is activated properly in your shell. Clone the following and check out the latest version of the node. Please refer to the cardano-node releases page to ensure you are working with the latest version of this. #install-cardano-node git clone --depth 1 https://github.com/input-output-hk/cardano-node cd cardano-node git fetch --all --recurse-submodules --tags #latesttag=$(git describe --tags) #git checkout tags/$latesttag git checkout tags/1.29.0 Create a file in the root of the git repository we just cloned and save it as plutus-tutorial.nix : file://tutorials/plutus/plutus-tutorial.nix { version ? \"mainnet\" , pkgs ? import ( fetchTarball \"https://github.com/NixOS/nixpkgs/archive/6525bbc06a39f26750ad8ee0d40000ddfdc24acb.tar.gz\" ) { }}: let cardano-node-repo = import . /. { }; in pkgs . mkShell { buildInputs = with pkgs ; [ libsodium cabal-install zlib haskell . compiler . ghc8104 haskellPackages . haskell-language-server cardano-node-repo . scripts . \" ${ version } \" . node cardano-node-repo . cardano-cli ]; CARDANO_NODE_SOCKET_PATH = \" ${ builtins . toString . /. } /state-node- ${ version } /node.socket\" ; } and then load a shell with Nix using this file with the following command: #start-nix-shell nix-shell ./plutus-tutorial.nix This will take approximately five or ten minutes the first time you do it, you should see something similar to this: these paths will be fetched ( 445 .08 MiB download, 5870 .53 MiB unpacked ) : /nix/store/04jc7s1006vhg3qj4fszg6bcljlyap1a-conduit-parse-0.2.1.0-doc /nix/store/052kzx9p5fl52pk436i2jcsqkz3ni0r2-reflection-2.1.6-doc . . . /nix/store/7jq1vjy58nj8rjwa688l5x7dyzr55d9f-monad-memo-0.5.3... ( 34 KB left ) This creates an environment with all dependencies listed in the \u201cbuildInputs\u201d section, with GHC 8.10.4 and Cabal among these. Once you have recent versions of GHC and Cabal, make sure to use GHC 8.10.2 or later: #verify-ghc-version ghc --version cabal --version","title":"Setting up the environment"},{"location":"06-Plutus-transactions/#running-the-cardano-node","text":"Inside the nix-shell start a passive Cardano node, remember to first activate the Nix environment if you have not done so: nix-shell plutus-tutorial.nix ** [ nix-shell:~ ] ** #start-passive-cardano-node cardano-node-mainnet At this point, the node will start syncing with the network, which will come useful for submitting our transactions later. We are now ready to start building the Plutus transaction. Keep the node running in this shell, and open a new terminal to continue with the following steps. Remember to enter the nix-shell environment in this new terminal so you have both GHC and Cabal available.","title":"Running the cardano-node"},{"location":"06-Plutus-transactions/#ensure-that-you-have-the-latest-tagged-version-era","text":"In a new terminal, i.e. the cardano node should still be running in the old terminal. #ensure-you-are-in-alonzo cardano-cli query tip ${ NETWORK_ID } You should now see the following: { \"epoch\" : 155 , \"hash\" : \"c8ae0bb7f06743cd95c35e19c866a811b7a3f104ad362c8667b9f0a1f0907ed2\" , \"slot\" : 36882965 , \"block\" : 2899736 , \"era\" : \"Alonzo\" , \"syncProgress\" : \"100.00\" } Note: Ensure that \u201cera\u201d corresponds to \u201cAlonzo\u201d. If you have just started the node, you might need to wait for your node to sync before you can see this. The node is not actually needed to build a transaction, but it is useful to submit the transaction to the network.","title":"Ensure that you have the latest tagged version era"},{"location":"06-Plutus-transactions/#generating-wallets","text":"We must first create a payment key-pair and a wallet address if you haven't already. For this example, we need to generate two addresses as follows. For this step, generate a payment key in the corresponding address: #generate-wallets cardano-cli address key-gen \\ --verification-key-file ./temp/ $OWNER .vkey \\ --signing-key-file ./temp/ $OWNER .skey cardano-cli stake-address key-gen \\ --verification-key-file ./temp/ $OWNER .stake.vkey \\ --signing-key-file ./temp/ $OWNER .stake.skey cardano-cli address build \\ --payment-verification-key-file ./temp/ $OWNER .vkey \\ --stake-verification-key-file ./temp/ $OWNER .stake.vkey \\ --out-file ./temp/ $OWNER .addr \\ $NETWORK_ID #generate-wallets Make sure to generate an additional wallet using the same steps above, so you can test transactions between these addresses.","title":"Generating Wallets"},{"location":"06-Plutus-transactions/#build-and-submit-a-simple-non-plutus-transaction","text":"In this simple transaction, we send funds from one personal address to another address. Assume that we have these addresses in payment.addr and payment2.addr files and we want to send 500 ADA from the first address to the second address. First, we need to query the UTXOs in the payment.addr : #verify-payment-address-has-funds cardano-cli query utxo --address ${ ALICE_ADDR } $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- 8c6f74370d823130847efe3d2e2e128f0e79c8e907fda692353d841dd0d6cb38 0 1000000000 lovelace + TxOutDatumHashNone #read-utxo-to-variable readonly UTXO_TXIX = $( cardano-cli query utxo $NETWORK_ID --address $ALICE_ADDR | select_utxo_with_most_value ) echo echo \"UTxO: $UTXO_TXIX \" Using this information, we can build a transaction: #build-transaction cardano-cli transaction build \\ --alonzo-era \\ $NETWORK_ID \\ --change-address ${ ALICE_ADDR } \\ --tx-in ${ UTXO_TXIX } \\ --tx-out $( cat ./temp/bob.addr ) +5000000 \\ --out-file ./temp/tx.build In the --tx-in argument we set the UTXO that we are using as input, the format of which is TxHash#TxIx. The --tx-out argument determines the output of the new UTXOs, the format of which is address+amount. As seen in the flow-diagram above, we can have one or more inputs and outputs. What follows is to sign and submit the transaction: #sign-simple-transaction cardano-cli transaction sign \\ --tx-body-file ./temp/tx.build \\ $NETWORK_ID \\ --signing-key-file ./temp/alice.skey \\ --out-file ./temp/tx.signed #submit-simple-transaction cardano-cli transaction submit --tx-file ./temp/tx.signed $NETWORK_ID Transaction successfully submitted. Now if we query payment2.addr we will have a new UTxO containing 500 ADAs: #query-2nd-address cardano-cli query utxo --address $( cat ./temp/bob.addr ) $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- d7d207438c90fe611c1a14be29974b1662f8563331bf6fba4b6569e089ffa561 1 500000000 lovelace + TxOutDatumHashNone #query-1st-address cardano-cli query utxo --address ${ ALICE_ADDR } $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- d7d207438c90fe611c1a14be29974b1662f8563331bf6fba4b6569e089ffa561 0 499831815 lovelace + TxOutDatumHashNone We have now sent a simple transaction.","title":"Build and submit a simple (non-Plutus) transaction"},{"location":"06-Plutus-transactions/#write-your-plutus-on-chain-code","text":"We need a Haskell program to compile our desired Plutus script. In this example we will use the plutus-alwayssucceeds Plutus script. Note The \u201cPlutus always succeeds\u201d script is used in this tutorial only as an example , as it uses a very simple protection mechanism that does not perform any validation of funds. Therefore, we recommend that you do not deploy this contract on the mainnet. If you still want to deploy it on mainnet, you should use a more secure datum. #clone-plutus-alwayssucceeds git clone https://github.com/input-output-hk/Alonzo-testnet.git cd Alonzo-testnet/resources/plutus-sources/plutus-alwayssucceeds Note that, even though the program is part of the testnet examples, it will work for us on mainnet just fine.","title":"Write your Plutus on chain code"},{"location":"06-Plutus-transactions/#serialize-your-plutus-on-chain-code","text":"By building the project, we generate a binary that compiles this script. #serialize-on-chain-code cabal update cabal build","title":"Serialize your Plutus on chain code"},{"location":"06-Plutus-transactions/#execute-the-plutus-alwayssucceeds-project","text":"We will pick a random number. It will be passed as an argument to the Plutus script (it is not used by the script right now, but will be required by transactions using the script). The second argument is the filename we want for the compiled Plutus script. #execute-alwayssucceeds cabal run plutus-alwayssucceeds -- 42 alwayssucceeds.plutus You should see something like this: Up to date Writing output to: alwayssucceeds.plutus \"Log output\" [] \"Ex Budget\" ExBudget { exBudgetCPU = ExCPU 297830 , exBudgetMemory = ExMemory 1100 } #print-serialized-alwayssucceeds cat alwayssucceeds.plutus You should see something like this: { \"type\" : \"PlutusScriptV1\" , \"description\" : \"\" , \"cborHex\" : \"4e4d01000033222220051200120011\" } We will then have the Plutus script compiled. Now, we need to build the transaction, using the cardano-cli project including the Plutus script.","title":"Execute the plutus-alwayssucceeds project"},{"location":"06-Plutus-transactions/#transaction-to-lock-funds","text":"A transaction to lock funds is very similar to a simple transaction. However, it has two key differences: we lock funds to a script address instead of a common one, and we need to specify a datum hash for every output. We use the plutus-alwayssucceeds Plutus validator script that we compiled earlier. This script will not check anything and will always succeed regardless of the value of the datum and redeemer. {-# INLINABLE mkValidator #-} mkValidator :: Data -> Data -> Data -> () mkValidator _ _ _ = () First, calculate the script address: #calculate-script-address cardano-cli address build \\ --payment-script-file ./temp/alwayssucceeds.plutus \\ $NETWORK_ID \\ --out-file ./temp/script.addr Now the script address is in the script.addr file: #calculate-script-address cat ./temp/script.addr We do not attach the datum to a UTXO directly but we use its hash. To get the hash of the datum, run the following cardano-cli command: #get-datum-hash export SCRIPTDATUMHASH = $( cardano-cli transaction hash-script-data --script-data-value 42 ) Next, get the protocol parameters and save them to a file named pparams.json using: #get-protocol-parameters cardano-cli query protocol-parameters \\ $NETWORK_ID \\ --out-file ./temp/pparams.json Now, we should build the transaction that will send ADA to the script address of our plutus-alwayssucceeds script. We write the transaction in a file called tx-script.build : #build-transaction-to-alwayssucceeds cardano-cli transaction build \\ --alonzo-era \\ $NETWORK_ID \\ --change-address ${ ALICE_ADDR } \\ --tx-in \" $UTXO_TXIX \" \\ --tx-out $( cat ./temp/script.addr ) +1379280 \\ --tx-out-datum-hash ${ SCRIPTDATUMHASH } \\ --protocol-params-file ./temp/pparams.json \\ --out-file ./temp/tx-script.build Continue to sign the transaction with the signing key payment.skey and save this signed transaction in a file tx-script.signed : #sign-transaction-to-alwayssucceeds cardano-cli transaction sign \\ --tx-body-file ./temp/tx-script.build \\ --signing-key-file ./temp/alice.skey \\ $NETWORK_ID \\ --out-file ./temp/tx-script.signed Finally, submit the transaction: #submit-transaction-to-alwayssucceeds cardano-cli transaction submit $NETWORK_ID --tx-file ./temp/tx-script.signed Transaction successfully submitted. We can query both personal and script addresses: #query-personal-and-script-addresses cardano-cli query utxo --address ${ ALICE_ADDR } $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- f5a618d579bc66e6199ae2a1ab4a73e2d8a73cba61a324c939346e9cf32bb33a 0 498284086 lovelace + TxOutDatumHashNone #get-script-address-balance export SCRIPT_ADDR = $( cat ./temp/script.addr ) cardano-cli query utxo --address $SCRIPT_ADDR $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- f5a618d579bc66e6199ae2a1ab4a73e2d8a73cba61a324c939346e9cf32bb33a 1 1379280 lovelace + TxOutDatumHash ScriptDataInAlonzoEra \"7c7c0bf83e0ed45faf3976a5ee19b4ef8bd069baab4275425161ac89d492bf82\" . . #plutusUtxoTxin # export PLUTUSUTXOTXIN=68a947f8ccb6845d3abf67376680509b476ea1cca187a486a93703bf59493f19#1 PLUTUSUTXOTXIN = $( cardano-cli query utxo --address $SCRIPT_ADDR $NETWORK_ID | grep \"1379280\" | tail -n1 | cut --delimiter = \" \" --output-delimiter = \"#\" -f 1 ,6 ) readonly PLUTUSUTXOTXIN Now, we have sent funds to a script.","title":"Transaction to lock funds"},{"location":"06-Plutus-transactions/#4-submit-transaction-to-execute-plutus-script","text":"To unlock funds from a script, we need the redeemer. Let\u2019s remember that this script will always succeed regardless of the value of the redeemer, so long as we provide the correct datum. So we can use any value as a redeemer. We also need an input as collateral: it covers the fees if the transaction fails. Then, we need a UTXO with enough funds. We are going to create a simple transaction using the payment2.addr account as an example. It results in two new UTXOs. Check the balances: #get-balance-2nd-address export BOB_ADDR = $( cat ./temp/bob.addr ) cardano-cli query utxo --address $BOB_ADDR $NETWORK_ID TxHash TxIx Amount -------------------------------------------------------------------------------------- d7d207438c90fe611c1a14be29974b1662f8563331bf6fba4b6569e089ffa561 1 500000000 lovelace + TxOutDatumHashNone #txCollateral export txCollateral = $( cardano-cli query utxo $NETWORK_ID --address $BOB_ADDR | select_utxo_with_most_value ) echo echo \"txCollateral: $txCollateral \" Construct, sign, and submit the new transaction to unlock the funds: #build-transaction-to-unlock-funds cardano-cli transaction build \\ --alonzo-era \\ $NETWORK_ID \\ --tx-in ${ PLUTUSUTXOTXIN } \\ --tx-in-script-file ./temp/alwayssucceeds.plutus \\ --tx-in-datum-value 42 \\ --tx-in-redeemer-value 42 \\ --tx-in-collateral ${ txCollateral } \\ --change-address ${ ALICE_ADDR } \\ --protocol-params-file ./temp/pparams.json \\ --out-file ./temp/test-alonzo.tx If we use a UTXO that is part of a script address as an input of the transaction, we need to specify the --tx-in-script-file --tx-in datum-value --tx-in-redeemer-value --tx-in-collateral arguments after the --tx-in argument containing that UTXO: #sign-transaction-to-unlock-funds cardano-cli transaction sign \\ --tx-body-file ./temp/test-alonzo.tx \\ --signing-key-file ./temp/bob.skey \\ $NETWORK_ID \\ --out-file ./temp/test-alonzo.signed #submit-transaction-to-unlock-funds cardano-cli transaction submit $NETWORK_ID --tx-file ./temp/test-alonzo.signed Transaction successfully submitted. Now, if we query both addresses we can see that we have unlocked the funds: #query-both-addresses echo \"Bob address has the funds liberated\" cardano-cli query utxo --address $( cat ./temp/bob.addr ) $NETWORK_ID echo \"now the contract address has one uxto less\" cardano-cli query utxo --address $( cat ./temp/script.addr ) $NETWORK_ID | grep \"1379280\" At this point, you have successfully submitted your first Plutus transaction!","title":"4. Submit transaction to execute Plutus script"},{"location":"06-Plutus-transactions/#automating-the-tutorial","text":"This tutorial is composed of four sections: Installing Cardano Node with Nixos Creating wallets Submitting a simple non-plutus transaction Submitting a plutus transaction On the following scripts we are going to automate what we told the user to type","title":"Automating the tutorial"},{"location":"06-Plutus-transactions/#creating-wallets","text":"file://tutorials/plutus/scripts/10_create_wallets.sh <<exe cute-in-bash-strict-mode>> #### Build and submit a simple (non-Plutus) transaction ### Ensure that you have the latest tagged version era. <<ensure-you-are-in-alonzo>> function create_wallets(){ local OWNER=$1 <<gen erate-wallets>> } create_wallets 'alice' # echo \"Calling the faucet API to get some funds for our new wallets\" # readonly APIKEY=$(cat ./secrets/api.key) # curl --insecure -v -XPOST \"https://faucet.cardano-testnet.iohkdev.io/send-money/${ALICE_ADDR}?apiKey=${APIKEY}\" ### create a 2nd address create_wallets 'bob' echo \"Wallets generated\" ### Once we have proven that the instructions to generate an address still work. # We will copy the known good adressess cp ./secrets/alice* ./temp/ cp ./secrets/bob* ./temp/ <<read-payment-address-to-variable>> <<verify-payment-address-has-funds>> <<read -utxo-to-variable>> assert_there_is_txhash $UTXO_TXIX # Now that we know that the instructions to create wallets work. # let's substitute the files, with the ones we know have funds, # so that the following tests also work.","title":"Creating wallets"},{"location":"06-Plutus-transactions/#submit-a-simple-non-plutus-transaction","text":"file://tutorials/plutus/scripts/20_submit_simple_transaction.sh <<exe cute-in-bash-strict-mode>> <<read-payment-address-to-variable>> <<read -utxo-to-variable>> <<build-transaction>> <<sign-simple-transaction>> <<sub mit-simple-transaction>> echo \"Awaiting Transaction to be committed...\" sleep 60 echo \"and the 2nd payment adress has 50,000,000 *more* lovelaces\" <<query-2nd-address>> echo \"and the 1st payment adress has 50,000,000 *less* lovelaces\" <<query -1st-address>> echo \"End: We were able to submit a simple transaction\"","title":"Submit a simple non Plutus transaction"},{"location":"06-Plutus-transactions/#submit-a-plutus-transaction","text":"file://tutorials/plutus/scripts/30_submit_plutus_transaction.sh <<execute-in-bash-strict-mode>> <<ensure-you-are-in-alonzo>> <<calculate-script-address>> <<get-datum-hash>> <<get-protocol-parameters>> <<read-payment-address-to-variable>> <<read-utxo-to-variable>> <<build-transaction-to-alwayssucceeds>> <<sign-transaction-to-alwayssucceeds>> <<submit-transaction-to-alwayssucceeds>> <<query-personal-and-script-addresses>> <<get-script-address-balance>> <<ensure-you-are-in-alonzo>> <<get-script-address-balance>> #copying busybox from the test script directory to bin cp ./busybox /bin/ ln -s -T /bin/busybox /bin/grep <<plutusUtxoTxin>> ### 4. Submit transaction to execute Plutus script <<get-balance-2nd-address>> <<txCollateral>> <<build-transaction-to-unlock-funds>> <<sig n-transaction-to-unlock-funds>> <<submit-trans action-to-unlock-funds>> <<query-both-addresses>> Now what we want is to create script / program that we can automatically execute with the steps we told the user to follow. A script that looks like this: <<exe cute-in-bash-strict-mode>> <<install-nix>> <<setup-binary-cache>> <<install -cardano-node>> cp ../tutorials/plutus/plutus-tutorial.nix .","title":"Submit a Plutus Transaction"},{"location":"06-Plutus-transactions/#bash-strict-mode","text":"This causes bash to behave in a way that makes many classes of subtle bugs impossible. You'll spend much less time debugging, and also avoid having unexpected complications in production. For more info: http://redsymbol.net/articles/unofficial-bash-strict-mode/ #execute-in-bash-strict-mode #The shebang must be the first line of the file, but then it get's mixed with entangled comments # this script must be executed with `bash $name_of_script` #!/bin/bash set -xeEuo pipefail #IFS=$'\\n\\t' function select_utxo_with_most_value () { cut --delimiter = ' ' --fields = 14 ,1,6 --only-delimited < /dev/stdin | \\ sort --human-numeric-sort --key = 3 | cut --delimiter = ' ' --fields = 1 ,2 --output-delimiter = \"#\" | \\ tail --lines = 1 > /dev/stdout } assert_not_empty (){ [ \" $var \" ] || { echo \"Parameter 1 is empty\" ; exit 1 ; } } assert_there_is_txhash (){ local var = \" $1 \" [ ${# var } == 66 ] || { echo \"TxHash can't be empty\" ; exit 1 ; } } readonly CARDANO_NODE_SOCKET_PATH = /ipc/node.socket readonly NETWORK_ID = \"--testnet-magic 1097911063\" # or \"--mainnet\" #read-payment-address-to-variable readonly ALICE_ADDR = $( cat ./temp/alice.addr ) echo echo \"Payment address is: $ALICE_ADDR \"","title":"Bash strict mode"},{"location":"06-Plutus-transactions/#inside-nix-shell","text":"Now what we want is to create script / program that we can automatically execute with the steps we told the user to follow. A script that looks like this: <<exe cute-in-bash-strict-mode>> <<verify-ghc-ver sion>> <<start-pas sive-cardano-node>> cd cardano-node","title":"Inside nix-shell"},{"location":"06-Plutus-transactions/#ultra","text":"How to execute this tests? In order to run this tutorial we need 3 containers: Cardano-node :: that is connected to the blockchain and downloading the blocks Cardano-cli :: that sends transactions to the Cardano-node Plutus compiler:: So that you can compile the plutus script used later. And also Cardano-node and the cardano-cli must be together. So in order to do that I use docker compose architecture file://tutorials/plutus/docker-compose.yml version : '3' services : cardano-node : image : inputoutput/cardano-node volumes : - ./cardano-testnet-1097911063/_data:/data - node-ipc:/ipc environment : - NETWORK=testnet node : image : inputoutput/cardano-node volumes : - node-ipc:/ipc:ro - ./:/plutus/ tty : true stdin_open : true environment : - CARDANO_NODE_SOCKET_PATH=/ipc/node.socket command : cli profiles : - cardano depends_on : - cardano-node plutus : image : inputoutput/plutus-starter-devcontainer volumes : node-ipc : external : true Then you can execute start the architecture simply as: docker-compose up --detach --remove-orphans And then you can join the cardano-cli node like this: docker-compose run node cli query tip --testnet-magic 1097911063 Now to execute the tests: docker-compose run --entrypoint = \"/bin/bash\" node ./scripts/10_creating_wallets.sh \" docker-compose run --entrypoint=\" /bin/bash \" node ./scripts/20_submit_simple_transaction.sh\" docker-compose run --entrypoint = \"/bin/bash\" node ./scripts/30_submit_plutus_transaction.sh \" we override the default entry point here so that it waits for a script file. In order to turn off the servers run this document docker-compose down","title":"Ultra"},{"location":"06-Plutus-transactions/#hyper-how-to-run-this-infraestructure-in-github-actions","text":"","title":"Hyper: How to run this infraestructure in GitHub actions"},{"location":"06-Plutus-transactions/#todo-everything-again-but-with-nix","text":"tutorial meta: things to make the tutorial work ultra: things to setup the docker instances where the the tutorial would work (docker-compose) hyper: make the tutorial execute in CI","title":"TODO : everything again but with Nix"},{"location":"about/","text":"About \u00b6 Entangled helps you write Literate Programs in Mardown. You put all your code inside Markdown code blocks. Entangled automatically extracts the code and writes it to more traditional source files. You can then edit these generated files, and the changes are being fed back to the Markdown. We're trying to increase the visibility of Entangled. If you like Entangled, please consider adding this badge to the appropriate location in your project: [![Entangled badge](https://img.shields.io/badge/entangled-Use%20the%20source!-%2300aeff)](https://entangled.github.io/)","title":"About"},{"location":"about/#about","text":"Entangled helps you write Literate Programs in Mardown. You put all your code inside Markdown code blocks. Entangled automatically extracts the code and writes it to more traditional source files. You can then edit these generated files, and the changes are being fed back to the Markdown. We're trying to increase the visibility of Entangled. If you like Entangled, please consider adding this badge to the appropriate location in your project: [![Entangled badge](https://img.shields.io/badge/entangled-Use%20the%20source!-%2300aeff)](https://entangled.github.io/)","title":"About"},{"location":"deployment/","text":"Continuouns Integration \u00b6 When we making any commit in this repository we want to autamically take the literate programming documents in 'docs' and extract the code from them (tangle) and update the website where they are exposed (weaving). To achive that automatation we are going to use GitHub actions. Basic structure of a GitHubAction \u00b6 I took this material from mkdocs-material Using [GitHub Actions] you can automate the deployment of your project documentation. At the root of your repository, create a new GitHub Actions workflow, e.g. .github/workflows/ci.yml , and copy and paste the following contents: file://.github/workflows/ci.yml name : ci # (1)! on : push : branches : # (2)! - master jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - uses : actions/setup-python@v2 with : python-version : 3.x <<tangle_code_files>> <<weave_mkdocs_site>> You can change the name to your liking. At some point, GitHub renamed master to main . If your default branch is named master , you can safely remove main , vice versa. This is the place to install further [MkDocs plugins] or Markdown extensions with pip to be used during the build: pip install \\ mkdocs-material \\ mkdocs-awesome-pages-plugin \\ ... Tangle \u00b6 We first need to generate all the code files from the literate markdown files. In order to do that we will entangled. #tangle_code_files - run : pip install entangled-filters - run : wget https://github.com/entangled/entangled/releases/download/v1.2.4/entangled-1.2.4-x86_64-GNU-Linux.tar.xz && tar --extract --file entangled-1.2.4-x86_64-GNU-Linux.tar.xz && sudo cp -r ./entangled-1.2.4/* /usr/local/ - run : entangled tangle -a Weaving \u00b6 Is the process of taking the literate markdown files and generating a beautiful website for humans to consume #weave_mkdocs_site - run : pip install mkdocs-material # (3)! - run : mkdocs gh-deploy --force","title":"Deployment"},{"location":"deployment/#continuouns-integration","text":"When we making any commit in this repository we want to autamically take the literate programming documents in 'docs' and extract the code from them (tangle) and update the website where they are exposed (weaving). To achive that automatation we are going to use GitHub actions.","title":"Continuouns Integration"},{"location":"deployment/#basic-structure-of-a-githubaction","text":"I took this material from mkdocs-material Using [GitHub Actions] you can automate the deployment of your project documentation. At the root of your repository, create a new GitHub Actions workflow, e.g. .github/workflows/ci.yml , and copy and paste the following contents: file://.github/workflows/ci.yml name : ci # (1)! on : push : branches : # (2)! - master jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - uses : actions/setup-python@v2 with : python-version : 3.x <<tangle_code_files>> <<weave_mkdocs_site>> You can change the name to your liking. At some point, GitHub renamed master to main . If your default branch is named master , you can safely remove main , vice versa. This is the place to install further [MkDocs plugins] or Markdown extensions with pip to be used during the build: pip install \\ mkdocs-material \\ mkdocs-awesome-pages-plugin \\ ...","title":"Basic structure of a GitHubAction"},{"location":"deployment/#tangle","text":"We first need to generate all the code files from the literate markdown files. In order to do that we will entangled. #tangle_code_files - run : pip install entangled-filters - run : wget https://github.com/entangled/entangled/releases/download/v1.2.4/entangled-1.2.4-x86_64-GNU-Linux.tar.xz && tar --extract --file entangled-1.2.4-x86_64-GNU-Linux.tar.xz && sudo cp -r ./entangled-1.2.4/* /usr/local/ - run : entangled tangle -a","title":"Tangle"},{"location":"deployment/#weaving","text":"Is the process of taking the literate markdown files and generating a beautiful website for humans to consume #weave_mkdocs_site - run : pip install mkdocs-material # (3)! - run : mkdocs gh-deploy --force","title":"Weaving"},{"location":"doc_rot/","text":"Software rot \u00b6 Is a slow deterioration of software quality over time or its diminishing responsiveness that will eventually lead to software becoming faulty, unusable, or in need of upgrade. This is not a physical phenomenon: the software does not actually decay, but rather suffers from a lack of being responsive and updated with respect to the changing environment in which it resides. Documentation rot is \u00b6 when your documentation stops working because the environment (programs, operating systems, libraries) has changed. For example \u00b6 As Tech writer \u00b6 You write a tutorial and in the beginning everybody is happy with it. The explanations and the step by step instructions work well. However in just a few months and in the case of new techology even in a few days the tutorial doesn't work anymore frustrating new users and the writer. How can we avoid this destiny? Literate programming \u00b6 Is a programming paradigm in which the main goal is to write document, that explains to other humans the intentions of your code. By writing a book / article intertwined with code. Then the code is separated in an operation named Tangle And the article is prepared for publication in an operation called weaving Elments of a software tutorial \u00b6 Description of the software Installation and setup Prerequisites Installation Configuration (if needed) Basic example Example input step by step instructions that the user should perform Expected output Conclusion and next steps Given that I present a (basic tutorial to use pandoc)[../pandoc/] A basic tutorial example \u00b6 Clarity is not enough \u00b6 Our tutorial is very, simple and easy to follow. But that is not enough, we also need correctness The instructions that we indicate the user should actually and reliably work. So to do that we need to convert our tutorial into a script ... A Clear, Correct tutorial is not enough... \u00b6 Our tutorial is clearly explained and we know that the instructions we provide the user are correct. Now we need to make sure, that the tutorial remains correct. So we need to monitor the environment on which our tutorial is still working How to solve it. \u00b6 Let's look at a very simple tutorial, even a README \u00b6 A typical tutorial includes the following sections: Example for a tutorial \u00b6 The problem the user has The solution your tool Setup instructions prerequisites how to install your tool verify that the tool has been properly installed. Step by step instructions to solve a simple trivial version \"the problem\" How to compile the solution How to test the solution Invitiation to solve the big problem Pointers to next documentation more steps. So let's look at an example \u00b6 Theory beyond this point. \u00b6 A developer \u00b6 You have written an extremely comples algorithm and you even went away and wrote a paper to explain it to the next person in charge of maintaining your code. But deep down you know that invariably over time your article and your code are going to diverge so much that neither will make any sense. A tester \u00b6 Writes an extremely complite integration test, it goes from zero just a brand new operating system. All the way to installation and it even runs a few subtests in the new environment in order to make sure that one the user installs the software for the first time, it can be succesful. Even more that integration test could be used as the basis for many tutorials if only, tech writers read the code. How can we solve those problems? \u00b6 Literate programming \u00b6 Is a programming paradigm introduced by Donald Knuth in which a computer program is given an explanation of its logic in a natural language, such as English, interspersed with snippets of macros and traditional source code, from which compilable source code can be generated.[1] Philosophy \u00b6 \u201cPrograms must be written for people to read, and only incidentally for machines to execute.\u201d \u2015 Harold Abelson \u201cLet us change our traditional attitude to the construction of programs. Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.\u201d \u2014 Donald Knuth Stages: \u00b6 Writting \u00b6 Writing about a comprehensive document about the program, the code and its maintenance. Weaving \u00b6 Generating a beautiful documentation Tangling \u00b6 Generating machine executable code \u00b6","title":"Documentation Rot"},{"location":"doc_rot/#software-rot","text":"Is a slow deterioration of software quality over time or its diminishing responsiveness that will eventually lead to software becoming faulty, unusable, or in need of upgrade. This is not a physical phenomenon: the software does not actually decay, but rather suffers from a lack of being responsive and updated with respect to the changing environment in which it resides.","title":"Software rot"},{"location":"doc_rot/#documentation-rot-is","text":"when your documentation stops working because the environment (programs, operating systems, libraries) has changed.","title":"Documentation rot is"},{"location":"doc_rot/#for-example","text":"","title":"For example"},{"location":"doc_rot/#as-tech-writer","text":"You write a tutorial and in the beginning everybody is happy with it. The explanations and the step by step instructions work well. However in just a few months and in the case of new techology even in a few days the tutorial doesn't work anymore frustrating new users and the writer. How can we avoid this destiny?","title":"As Tech writer"},{"location":"doc_rot/#literate-programming","text":"Is a programming paradigm in which the main goal is to write document, that explains to other humans the intentions of your code. By writing a book / article intertwined with code. Then the code is separated in an operation named Tangle And the article is prepared for publication in an operation called weaving","title":"Literate programming"},{"location":"doc_rot/#elments-of-a-software-tutorial","text":"Description of the software Installation and setup Prerequisites Installation Configuration (if needed) Basic example Example input step by step instructions that the user should perform Expected output Conclusion and next steps Given that I present a (basic tutorial to use pandoc)[../pandoc/]","title":"Elments of a software tutorial"},{"location":"doc_rot/#a-basic-tutorial-example","text":"","title":"A basic tutorial example"},{"location":"doc_rot/#clarity-is-not-enough","text":"Our tutorial is very, simple and easy to follow. But that is not enough, we also need correctness The instructions that we indicate the user should actually and reliably work. So to do that we need to convert our tutorial into a script ...","title":"Clarity is not enough"},{"location":"doc_rot/#a-clear-correct-tutorial-is-not-enough","text":"Our tutorial is clearly explained and we know that the instructions we provide the user are correct. Now we need to make sure, that the tutorial remains correct. So we need to monitor the environment on which our tutorial is still working","title":"A Clear, Correct tutorial is not enough..."},{"location":"doc_rot/#how-to-solve-it","text":"","title":"How to solve it."},{"location":"doc_rot/#lets-look-at-a-very-simple-tutorial-even-a-readme","text":"A typical tutorial includes the following sections:","title":"Let's look at a very simple tutorial, even a README"},{"location":"doc_rot/#example-for-a-tutorial","text":"The problem the user has The solution your tool Setup instructions prerequisites how to install your tool verify that the tool has been properly installed. Step by step instructions to solve a simple trivial version \"the problem\" How to compile the solution How to test the solution Invitiation to solve the big problem Pointers to next documentation more steps.","title":"Example for a tutorial"},{"location":"doc_rot/#so-lets-look-at-an-example","text":"","title":"So let's look at an example"},{"location":"doc_rot/#theory-beyond-this-point","text":"","title":"Theory beyond this point."},{"location":"doc_rot/#a-developer","text":"You have written an extremely comples algorithm and you even went away and wrote a paper to explain it to the next person in charge of maintaining your code. But deep down you know that invariably over time your article and your code are going to diverge so much that neither will make any sense.","title":"A developer"},{"location":"doc_rot/#a-tester","text":"Writes an extremely complite integration test, it goes from zero just a brand new operating system. All the way to installation and it even runs a few subtests in the new environment in order to make sure that one the user installs the software for the first time, it can be succesful. Even more that integration test could be used as the basis for many tutorials if only, tech writers read the code.","title":"A tester"},{"location":"doc_rot/#how-can-we-solve-those-problems","text":"","title":"How can we solve those problems?"},{"location":"doc_rot/#literate-programming_1","text":"Is a programming paradigm introduced by Donald Knuth in which a computer program is given an explanation of its logic in a natural language, such as English, interspersed with snippets of macros and traditional source code, from which compilable source code can be generated.[1]","title":"Literate programming"},{"location":"doc_rot/#philosophy","text":"\u201cPrograms must be written for people to read, and only incidentally for machines to execute.\u201d \u2015 Harold Abelson \u201cLet us change our traditional attitude to the construction of programs. Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.\u201d \u2014 Donald Knuth","title":"Philosophy"},{"location":"doc_rot/#stages","text":"","title":"Stages:"},{"location":"doc_rot/#writting","text":"Writing about a comprehensive document about the program, the code and its maintenance.","title":"Writting"},{"location":"doc_rot/#weaving","text":"Generating a beautiful documentation","title":"Weaving"},{"location":"doc_rot/#tangling","text":"Generating machine executable code","title":"Tangling"},{"location":"doc_rot/#_1","text":"","title":""},{"location":"example_tutorial_pandoc/","text":"A basic pandoc tutorial \u00b7 \u00b6 The swiss-army knife to convert files. You can convert between this formats: \u2194\ufe0e Markdown (including CommonMark and GitHub-flavored Markdown) \u2194\ufe0e reStructuredText \u2192 AsciiDoc \u2194\ufe0e Emacs Org-Mode \u2194\ufe0e Emacs Muse \u2194\ufe0e Textile \u2190 txt2tags Installing / Getting started \u00b6 Installing Pandoc on Debian Ubuntu is very easy. #install_pandoc sudo apt install -y pandoc Converting from markdown to html \u00b6 As a basic example let's convert this markdown file to html5 file://tutorials/pandoc/hello_world.md # Hello World Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean augue neque, mattis nec mollis id, dictum at purus. Nullam ac justo tempor, hendrerit nisl sit amet, rutrum ex. > Aenean iaculis consectetur nisl vel egestas. In pandoc you would write #convert_from_md_to_html5 pandoc --from = markdown --to = html5 -s ./tutorials/pandoc/hello_world.md -o ./tutorials/pandoc/hello_world.html And then you would have hello_world.html file with the markdown converte to the correct one. file://tutorials/pandoc/tests/hello_world.html < h1 id = \"hello-world\" > Hello World </ h1 > < p > Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean augue neque, mattis nec mollis id, dictum at purus. Nullam ac justo tempor, hendrerit nisl sit amet, rutrum ex. </ p > < blockquote > < p > Aenean iaculis consectetur nisl vel egestas. </ p > </ blockquote > And with that we conclude the tutorial Automating the tutorial. \u00b6 Now what we want is to create script / program that we can automatically execute with the steps we told the user to follow. A script that looks like this: file://tutorials/pandoc/tests/scripted.test.sh #!/bin/bash set -euo pipefail IFS = $'\\n\\t' sudo su <<install_pandoc>> <<convert_from_md_to_html5>> <<veri fy_output_equal_expected_value>> How can we very the ouput equals the expected value? \u00b6 #verify_output_equal_expected_value if ! cmp ./tutorials/pandoc/hello_world.html ./tutorials/pandoc/tests/hello_world.html 2 > & 1 then echo \"The generated hello_world.html is not identical to the expected....\" exit 1 ; fi Monitoring \u00b6 To avoid documentation rot we need to make sure our tutorial works and continues to work day in and day out. Finally we need to keep writing this tests at least once a day, to make sure it continues to work. In order to do that we will use a GitHub Action. GitHub Actions are processes that get executed on GitHub's Servers when ever there is a push to your source code repository. file://.github/workflows/monitor_tutorial_tests.yml name : Schedule test execution on : schedule : - cron : \"0 0 * * *\" jobs : pull_data : runs-on : ubuntu-20.04 steps : - name : Checkout code uses : actions/checkout@v2 with : persist-credentials : false fetch-depth : 0 - name : Set up Python 3.8 uses : actions/setup-python@v2 with : python-version : \"3.8\" # Let's execute the testing script - name : Execute test scripts for all the tutorials run : find ./tutorials/ -name \"*.test.sh\" | xargs bash","title":"An example tutorial"},{"location":"example_tutorial_pandoc/#a-basic-pandoc-tutorial","text":"The swiss-army knife to convert files. You can convert between this formats: \u2194\ufe0e Markdown (including CommonMark and GitHub-flavored Markdown) \u2194\ufe0e reStructuredText \u2192 AsciiDoc \u2194\ufe0e Emacs Org-Mode \u2194\ufe0e Emacs Muse \u2194\ufe0e Textile \u2190 txt2tags","title":"A basic pandoc tutorial &middot;"},{"location":"example_tutorial_pandoc/#installing-getting-started","text":"Installing Pandoc on Debian Ubuntu is very easy. #install_pandoc sudo apt install -y pandoc","title":"Installing / Getting started"},{"location":"example_tutorial_pandoc/#converting-from-markdown-to-html","text":"As a basic example let's convert this markdown file to html5 file://tutorials/pandoc/hello_world.md # Hello World Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean augue neque, mattis nec mollis id, dictum at purus. Nullam ac justo tempor, hendrerit nisl sit amet, rutrum ex. > Aenean iaculis consectetur nisl vel egestas. In pandoc you would write #convert_from_md_to_html5 pandoc --from = markdown --to = html5 -s ./tutorials/pandoc/hello_world.md -o ./tutorials/pandoc/hello_world.html And then you would have hello_world.html file with the markdown converte to the correct one. file://tutorials/pandoc/tests/hello_world.html < h1 id = \"hello-world\" > Hello World </ h1 > < p > Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean augue neque, mattis nec mollis id, dictum at purus. Nullam ac justo tempor, hendrerit nisl sit amet, rutrum ex. </ p > < blockquote > < p > Aenean iaculis consectetur nisl vel egestas. </ p > </ blockquote > And with that we conclude the tutorial","title":"Converting from markdown to html"},{"location":"example_tutorial_pandoc/#automating-the-tutorial","text":"Now what we want is to create script / program that we can automatically execute with the steps we told the user to follow. A script that looks like this: file://tutorials/pandoc/tests/scripted.test.sh #!/bin/bash set -euo pipefail IFS = $'\\n\\t' sudo su <<install_pandoc>> <<convert_from_md_to_html5>> <<veri fy_output_equal_expected_value>>","title":"Automating the tutorial."},{"location":"example_tutorial_pandoc/#how-can-we-very-the-ouput-equals-the-expected-value","text":"#verify_output_equal_expected_value if ! cmp ./tutorials/pandoc/hello_world.html ./tutorials/pandoc/tests/hello_world.html 2 > & 1 then echo \"The generated hello_world.html is not identical to the expected....\" exit 1 ; fi","title":"How can we very the ouput equals the expected value?"},{"location":"example_tutorial_pandoc/#monitoring","text":"To avoid documentation rot we need to make sure our tutorial works and continues to work day in and day out. Finally we need to keep writing this tests at least once a day, to make sure it continues to work. In order to do that we will use a GitHub Action. GitHub Actions are processes that get executed on GitHub's Servers when ever there is a push to your source code repository. file://.github/workflows/monitor_tutorial_tests.yml name : Schedule test execution on : schedule : - cron : \"0 0 * * *\" jobs : pull_data : runs-on : ubuntu-20.04 steps : - name : Checkout code uses : actions/checkout@v2 with : persist-credentials : false fetch-depth : 0 - name : Set up Python 3.8 uses : actions/setup-python@v2 with : python-version : \"3.8\" # Let's execute the testing script - name : Execute test scripts for all the tutorials run : find ./tutorials/ -name \"*.test.sh\" | xargs bash","title":"Monitoring"},{"location":"setup/","text":"Entangled and MkDocs \u00b6 This is a setup of Entangled with MkDocs, using: mkdocs-material theme (which is almost a cms) mathjax Prep \u00b6 Install entangled (\u2265 1.2) following the instructions at entangled.github.io . #install_entangled RUN wget https://github.com/entangled/entangled/releases/download/v1.2.4/entangled-1.2.4-x86_64-GNU-Linux.tar.xz && tar --extract --file entangled-1.2.4-x86_64-GNU-Linux.tar.xz && sudo cp -r ./entangled-1.2.4/* /usr/local/ Install the entangled-filters Python module (\u2265 0.7) #install_filters RUN sudo pip install entangled-filters Install mkdocs #install_mkdocs RUN sudo pip install mkdocs Install material theme #install_mkdocs_material RUN sudo pip install mkdocs-material This could be setup in a docker file with this structure \u00b6 file://.gitpod.Dockerfile FROM gitpod/workspace-full <<install_entangled>> <<install_fi lters>> <<install_mkdocs>> <<install_mkdocs_materi al>> Starting a project \u00b6 To run Entangled we need a entangled.dhall configuration file. The following command generates a file that you can edit to suit your needs. entangled config > entangled.dhall We have our Markdown inside the docs folder, so you'll need to set the watchList variable to [ \"docs/**/*.md\" ] . let watchList = [ \"docs/**/*.md\" ] In this project we use a different Markdown syntax than is standard with Entangled. ```cpp title=\"file://src/hello.cc\" ``` ```cpp title=\"#print-hello\" ``` To match these code blocks, we need to change the syntax value in the configuration. let syntax : entangled.Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id=\\\"([^\\\"]*)\\\".*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file=\\\"([^\\\"]*)\\\".*\" } To initiate a MkDocs project, you need a mkdocs.yml file. This contains the meta-data of the site, file://mkdocs.yml nav : - Home : \"index.md\" - Documentation Rot : \"doc_rot.md\" - An example tutorial : \"example_tutorial_pandoc.md\" - About : \"about.md\" - Experiments : \"syntax_experiments.md\" - Deployment : \"deployment.md\" site_name : TODO insert your site name site_url : https://TODO.github.io/_project_name repo_url : https://github.com/TODO/mkdocs site_description : > TODO describe your site site_author : TODO your name copyright : TODO your organization's name and the configuration file://mkdocs.yml <<theme>> markdown_extensions : <<markdown-extensions>> - admonition - toc : permalink : true extra_css : <<extra-css>> extra_javascript : <<extra-javascript>> Material theme \u00b6 Install the material theme with pip install mkdocs-material #theme theme : name : material Annotating code blocks \u00b6 The entangled-filters module, while mainly dedicated to Pandoc support, has a few functions to help us pass metadata through mkdocs . By default, mkdocs will not allow any extra attributes to be added to the code blocks. We need to configure pymdownx.superfences extension to get what we need. #markdown-extensions - pymdownx.highlight : anchor_linenums : true - pymdownx.inlinehilite - pymdownx.snippets - pymdownx.superfences Highlighting \u00b6 To enable syntax highlighting you need to configure highlight.js . #extra-css Equations \u00b6 Here's everything we know about gravity \\[G_{\\mu\\nu} + \\Lambda g_{\\mu\\nu} = \\frac{8\\pi G}{c^4} T_{\\mu\\nu}\\] #markdown-extensions - pymdownx.arithmatex #extra-javascript - \"https://polyfill.io/v3/polyfill.min.js?features=es6\" - \"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"","title":"Setup"},{"location":"setup/#entangled-and-mkdocs","text":"This is a setup of Entangled with MkDocs, using: mkdocs-material theme (which is almost a cms) mathjax","title":"Entangled and MkDocs"},{"location":"setup/#prep","text":"Install entangled (\u2265 1.2) following the instructions at entangled.github.io . #install_entangled RUN wget https://github.com/entangled/entangled/releases/download/v1.2.4/entangled-1.2.4-x86_64-GNU-Linux.tar.xz && tar --extract --file entangled-1.2.4-x86_64-GNU-Linux.tar.xz && sudo cp -r ./entangled-1.2.4/* /usr/local/ Install the entangled-filters Python module (\u2265 0.7) #install_filters RUN sudo pip install entangled-filters Install mkdocs #install_mkdocs RUN sudo pip install mkdocs Install material theme #install_mkdocs_material RUN sudo pip install mkdocs-material","title":"Prep"},{"location":"setup/#this-could-be-setup-in-a-docker-file-with-this-structure","text":"file://.gitpod.Dockerfile FROM gitpod/workspace-full <<install_entangled>> <<install_fi lters>> <<install_mkdocs>> <<install_mkdocs_materi al>>","title":"This could be setup in a docker file with this structure"},{"location":"setup/#starting-a-project","text":"To run Entangled we need a entangled.dhall configuration file. The following command generates a file that you can edit to suit your needs. entangled config > entangled.dhall We have our Markdown inside the docs folder, so you'll need to set the watchList variable to [ \"docs/**/*.md\" ] . let watchList = [ \"docs/**/*.md\" ] In this project we use a different Markdown syntax than is standard with Entangled. ```cpp title=\"file://src/hello.cc\" ``` ```cpp title=\"#print-hello\" ``` To match these code blocks, we need to change the syntax value in the configuration. let syntax : entangled.Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id=\\\"([^\\\"]*)\\\".*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file=\\\"([^\\\"]*)\\\".*\" } To initiate a MkDocs project, you need a mkdocs.yml file. This contains the meta-data of the site, file://mkdocs.yml nav : - Home : \"index.md\" - Documentation Rot : \"doc_rot.md\" - An example tutorial : \"example_tutorial_pandoc.md\" - About : \"about.md\" - Experiments : \"syntax_experiments.md\" - Deployment : \"deployment.md\" site_name : TODO insert your site name site_url : https://TODO.github.io/_project_name repo_url : https://github.com/TODO/mkdocs site_description : > TODO describe your site site_author : TODO your name copyright : TODO your organization's name and the configuration file://mkdocs.yml <<theme>> markdown_extensions : <<markdown-extensions>> - admonition - toc : permalink : true extra_css : <<extra-css>> extra_javascript : <<extra-javascript>>","title":"Starting a project"},{"location":"setup/#material-theme","text":"Install the material theme with pip install mkdocs-material #theme theme : name : material","title":"Material theme"},{"location":"setup/#annotating-code-blocks","text":"The entangled-filters module, while mainly dedicated to Pandoc support, has a few functions to help us pass metadata through mkdocs . By default, mkdocs will not allow any extra attributes to be added to the code blocks. We need to configure pymdownx.superfences extension to get what we need. #markdown-extensions - pymdownx.highlight : anchor_linenums : true - pymdownx.inlinehilite - pymdownx.snippets - pymdownx.superfences","title":"Annotating code blocks"},{"location":"setup/#highlighting","text":"To enable syntax highlighting you need to configure highlight.js . #extra-css","title":"Highlighting"},{"location":"setup/#equations","text":"Here's everything we know about gravity \\[G_{\\mu\\nu} + \\Lambda g_{\\mu\\nu} = \\frac{8\\pi G}{c^4} T_{\\mu\\nu}\\] #markdown-extensions - pymdownx.arithmatex #extra-javascript - \"https://polyfill.io/v3/polyfill.min.js?features=es6\" - \"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"","title":"Equations"},{"location":"slasher/","text":"What better waste of time than writing a mind numbing game in a language you don't know? Let's dive into Elm . Elm is a strongly typed functional language that compiles to JavaScript. Its design is centred around the Model/View/Controller concept. This document may teach you: Basics of Elm Writing a small browser based game Random numbers in Elm (through Cmd/Msg loop) Generate SVG Our game is simple. The original slasher game is one I remember from way back when I was playing with GW Basic . Your hero is zipping around the screen at break neck speeds and the only way to control him is by placing slash \u2571 and backslash \u2572 characters from which it bounces off. The goal is to catch the golden snitch which only stays in one place for so long. {#fig:slasher-screenshot} You can play this game here. Main \u00b6 Elm has a set of different application formats, depending on the level of interactivity that is needed: sandbox : has no interaction with outside world, except through buttons, text fields and forms. element : can talk to HTTP, use random numbers, and capture browser events. document : similar to element, but generates the entire document. application : also handles URL requests and URL changes. The Elm guide has a section describing the difference between sandbox and element . The event loop of element looks like this: {#fig:elm-event-loop} We will be creating an element program, compile it to a JavaScript file, and create a HTML and CSS around it by hand. The lay-out of such a program in Elm looks as follows: module Main exposing (..) << imports >> << main >> << model >> << update >> << subscriptions >> << view >> The main function tells Elm that we create an element main main = Browser . element { init = init , update = update , subscriptions = subscriptions , view = view } The rest of the program has: model : Data model of the game. In strongly typed functional languages the design of a program always starts with thinking about type definitions. update : Defines how to propagate the model from one state to the next. subscriptions : Subscriptions to external events, that is, events that cannot be bound to an action on a HTML element. view : Describes how to translate the model state into an HTML element. Imports \u00b6 imports import Browser import Array exposing ( Array , repeat , indexedMap , toList , set , get ) import List exposing ( concat ) import Browser.Events exposing ( onAnimationFrameDelta , onKeyDown ) import Html exposing ( Html , button , div , text , p , input , main_ , a ) import Html.Attributes exposing ( href ) import Html.Events exposing ( onClick , preventDefaultOn ) import Svg exposing ( svg , circle , line , rect , g , polygon , text_ ) import Svg.Attributes exposing (..) import Random import Json.Decode as Decode The Model \u00b6 The model will be a grid of cells and two actors: our hero and the snitch (if you like to play around with the code, try to add a list of enemy actors that can hurt the hero). type alias Model = { actors : { player : Actor , snitch : Actor } , grid : Grid , snitchTime : Float , state : GameState } In addition to the actors and the grid , we have to keep time, and a game state flag. The game state tells us if the game is running etc. type GameState = Start | Running | Pause | Won We define the grid as nested arrays of cells, where each cell can have the value Empty , Slash or BackSlash : type alias Grid = Array ( Array Cell ) type Cell = Empty | Slash | BackSlash gridRef : ( Int , Int ) -> Grid -> Cell gridRef ( i , j ) grid = Maybe . withDefault Empty <| Maybe . andThen ( \\ row -> get i row ) ( get j grid ) gridSet : ( Int , Int ) -> Cell -> Grid -> Grid gridSet ( i , j ) cell grid = let row_ = get j grid in case row_ of Nothing -> grid Just row -> set j ( set i cell row ) grid Lastly, an Actor is something that has a location and a velocity, each a 2-tuple of floats. type alias Actor = { location : ( Float , Float ) , velocity : ( Float , Float ) } Config \u00b6 type alias Config = { gridSize : ( Int , Int ) , playerSpeed : Float , scale : Int , snitchTime : Float } config : Config config = { gridSize = ( 80 , 50 ) , playerSpeed = 0. 03 , scale = 15 , snitchTime = 10000 } inRange : ( Int , Int ) -> Bool inRange ( i , j ) = let ( w , h ) = config . gridSize in i >= 0 && i < w && j >= 0 && j < h Init \u00b6 The model is initialised by the init function. This function has the funny signature () -> (Model, Cmd Msg) . We'll return to the type definition of Msg later, but what this means is that the init function generates an initial state and a command (or list of commands) that tells the Elm run-time to perform an action upon initialisation. Such an action can be anything that requires some form of external state: HTTP requests, location/time information, and in our case: generating random numbers. init : () -> ( Model , Cmd Msg ) init _ = let ( width , height ) = config . gridSize playerLoc = (( toFloat width ) / 2 + 0. 5 , 2. 5 ) in ( { actors = { player = { location = playerLoc , velocity = ( 0. 0 , config . playerSpeed ) } , snitch = { location = ( 0. 0 , 0. 0 ) , velocity = ( 0. 0 , 0. 0 ) } } , grid = makeGrid config . gridSize , snitchTime = 0. 0 , state = Start }, Random . generate PlaceSnitch ( Random . pair ( Random . int 0 ( width - 1 )) ( Random . int 0 ( height - 1 )))) makeGrid : ( Int , Int ) -> Array ( Array Cell ) makeGrid ( width , height ) = Array . repeat height ( Array . repeat width Empty ) Subscriptions \u00b6 keyDecoder : Decode . Decoder Msg keyDecoder = Decode . map KeyPress ( Decode . field \"key\" Decode . string ) subscriptions : Model -> Sub Msg subscriptions model = Sub . batch [ onAnimationFrameDelta TimeStep , onKeyDown keyDecoder ] Update \u00b6 The update function has the following signature: update : Msg -> Model -> ( Model , Cmd Msg ) This means that, given a message and a model state, we can generate a new model state and a list of requests to the Elm run-time. This list of requests has the type Cmd Msg , telling Elm that, whatever the request, it has to respond with a Msg . type Msg = KeyPress String | TimeStep Float | PlaceSnitch ( Int , Int ) In our case, a message is either a KeyPress indicating a key being pressed, a TimeStep when a new animation frame is triggered or a PlaceSnitch when the random number generator returns a fresh pair of coordinates. We'll defer the handling of these messages to helper functions. update msg model = case msg of TimeStep dt -> let next = timeStep dt model in ( next , checkSnitchTime next ) KeyPress k -> ( keyMap k model , Cmd . none ) PlaceSnitch l -> ( placeSnitch l model , Cmd . none ) << msg - type >> << update - function >> Time step \u00b6 Each time step, if the game in in Running state, we need to check if the game is won, and otherwise move all actors that need moving. timeStep : Float -> Model -> Model timeStep dt ({ actors , grid , snitchTime , state } as model ) = case state of Running -> if didWeWin model then { model | state = Won } else { model | snitchTime = snitchTime - dt , actors = { actors | player = updateActor grid dt actors . player } } _ -> model Did we win? \u00b6 didWeWin : Model -> Bool didWeWin ({ actors } as model ) = activeCell actors . snitch == activeCell actors . player Update actors \u00b6 Updating an actor is a bit of boring bookkeeping. We check whether the actor's active grid cell changes. This happens when the actor moves across the center of a cell. If the active cell changed, potentially the actor bounced off a (back)slash or a wall. updateActor : Grid -> Float -> Actor -> Actor updateActor grid dt actor = let a = activeCell actor b = activeCell <| moveActor dt actor in if a /= b then case ( gridRef a grid ) of Slash -> bounceActor dt Slash actor BackSlash -> bounceActor dt BackSlash actor Empty -> if inRange b then moveActor dt actor else bounceOffWall dt actor else moveActor dt actor Active cell \u00b6 To get a smooth flying experience the actors have floating point coordinates. From the coordinates we need to compute the integer indices into the grid. activeCell : Actor -> ( Int , Int ) activeCell actor = let ( x , y ) = actor . location in case ( actorDirection actor ) of East -> ( round x , floor y ) West -> ( round ( x - 1. 0 ), floor y ) North -> ( floor x , round ( y - 1. 0 )) South -> ( floor x , round y ) Direction \u00b6 From the velocity we often need to know in which of the four cardinal directions an actor is moving. type Direction = North | East | South | West actorDirection : Actor -> Direction actorDirection actor = let ( vx , vy ) = actor . velocity in if ( abs vx ) > ( abs vy ) then if vx > 0 then East else West else if vy > 0 then South else North Actor dynamics \u00b6 When an actor moves, it may do so in one of three ways: move without obstacle bounce off a (back)slash) bounce off the wall For each of these cases we have a separate function. moveActor : Float -> Actor -> Actor moveActor dt actor = let ( x , y ) = actor . location ( vx , vy ) = actor . velocity in { actor | location = ( x + dt * vx , y + dt * vy ) } bounceActor : Float -> Cell -> Actor -> Actor bounceActor dt cell actor = let ( i , j ) = activeCell actor ( vx , vy ) = actor . velocity newloc = (( toFloat i ) + 0. 5 , ( toFloat j ) + 0. 5 ) in case cell of Slash -> moveActor dt { location = newloc , velocity = ( - vy , - vx ) } BackSlash -> moveActor dt { location = newloc , velocity = ( vy , vx ) } Empty -> actor bounceOffWall : Float -> Actor -> Actor bounceOffWall dt actor = let ( x , y ) = actor . location ( vx , vy ) = actor . velocity newloc = case actorDirection actor of North -> ( x , 0. 0 ) South -> ( x , 50. 0 ) East -> ( 80. 0 , y ) West -> ( 0. 0 , y ) in moveActor dt { location = newloc , velocity = ( - vx , - vy ) } Snitch time \u00b6 Each time step we decreased the snitchTime field. If it drops below 0, we ask the Elm runtime for a new random snitch location. checkSnitchTime : Model -> Cmd Msg checkSnitchTime { snitchTime } = let ( w , h ) = config . gridSize in if snitchTime < 0. 0 then Random . generate PlaceSnitch ( Random . pair ( Random . int 0 ( w - 1 )) ( Random . int 0 ( h - 1 ))) else Cmd . none Moving the snitch \u00b6 When the snitch is placed we reset the snitchTime to the configured value placeSnitch : ( Int , Int ) -> Model -> Model placeSnitch ( x , y ) ({ actors } as model ) = { model | snitchTime = config . snitchTime , actors = { actors | snitch = { location = (( toFloat x ) + 0. 5 , ( toFloat y ) + 0. 5 ) , velocity = ( 0. 0 , 0. 0 ) } } } Keymap \u00b6 We listen to three keys: space, left arrow and right arrow. We could have listened for \\ and / keys, but in Firefox the / key also activates quick search. We could work around this, but it is a bit of a hassle. keyMap : String -> Model -> Model keyMap k ({ state } as model ) = let slash cell = if state == Running then place cell model else model in case k of \" \" -> let newState = case state of Running -> Pause Start -> Running Pause -> Running Won -> Won in { model | state = newState } \"ArrowLeft\" -> slash BackSlash \"ArrowRight\" -> slash Slash _ -> model Placing a (back)slash \u00b6 place : Cell -> Model -> Model place cell ({ actors , grid } as model ) = let loc = activeCell actors . player in { model | grid = gridSet loc cell grid } View \u00b6 scale : Int scale = config . scale fScale : Float fScale = toFloat scale viewCell : ( Int , Int ) -> Cell -> List ( Html Msg ) viewCell ( i , j ) c = case c of Slash -> [ line [ x1 ( String . fromInt ( scale * i + scale )) , y1 ( String . fromInt ( scale * j )) , x2 ( String . fromInt ( scale * i )) , y2 ( String . fromInt ( scale * j + scale )) , class \"slash\" ] [] ] BackSlash -> [ line [ x1 ( String . fromInt ( scale * i )) , y1 ( String . fromInt ( scale * j )) , x2 ( String . fromInt ( scale * i + scale )) , y2 ( String . fromInt ( scale * j + scale )) , class \"slash\" ] [] ] Empty -> [] formatPath : List ( Float , Float ) -> String formatPath pts = case pts of [] -> \"\" ( x , y ) :: rest -> ( String . fromFloat <| x * fScale ) ++ \",\" ++ ( String . fromFloat <| y * fScale ) ++ \" \" ++ formatPath rest viewHero : Actor -> Html Msg viewHero actor = let ( x , y ) = actor . location path = case actorDirection actor of South -> [ ( x , y ) , ( x + 0. 3 , y - 1 ) , ( x - 0. 3 , y - 1 ) ] North -> [ ( x , y ) , ( x + 0. 3 , y + 1 ) , ( x - 0. 3 , y + 1 ) ] West -> [ ( x , y ) , ( x + 1 , y + 0. 3 ) , ( x + 1 , y - 0. 3 ) ] East -> [ ( x , y ) , ( x - 1 , y + 0. 3 ) , ( x - 1 , y - 0. 3 ) ] in polygon [ points <| formatPath path , class \"hero\" ] [] viewSnitch : Actor -> Html Msg viewSnitch actor = let ( x , y ) = actor . location in circle [ cx ( String . fromFloat <| x * fScale ) , cy ( String . fromFloat <| y * fScale ) , r ( String . fromInt <| scale // 2 ) , class \"snitch\" ] [] viewOverlay : GameState -> Html Msg viewOverlay state = let ( w , h ) = config . gridSize sWidth = ( String . fromInt <| config . scale * w ) sHeight = ( String . fromInt <| config . scale * h ) middleX = ( String . fromInt <| config . scale * w // 2 ) middleY = ( String . fromInt <| config . scale * h // 2 ) rectA = rect [ x \"0\" , y \"0\" , width sWidth , height sHeight , rx ( String . fromInt <| scale ) , ry ( String . fromInt <| scale ) , style \"fill: black\" ] [] textA s = text_ [ x middleX , y middleY , textAnchor \"middle\" ] [ text s ] overlay s = g [ id \"overlay\" ] [ rectA , textA s ] in case state of Running -> g [] [] Won -> overlay \"YOU WIN!\" Start -> overlay \"press space to start\" Pause -> overlay \"PAUSE\" viewSnitchBar : Float -> Html Msg viewSnitchBar t = let u = t / config . snitchTime ( w , h ) = config . gridSize sWidth = String . fromFloat <| ( toFloat w ) * u * ( toFloat config . scale ) in rect [ x \"0\" , y ( String . fromInt <| h * config . scale + 10 ) , width sWidth , height ( String . fromInt <| config . scale // 2 ) , id \"snitch-bar\" ] [] viewArena : Model -> Html Msg viewArena ({ actors , grid , state , snitchTime } as model ) = let blurAtPause = class <| if state == Running then \"non-blurred\" else \"blurred\" in svg [ width \"100%\" , viewBox ( \"-3 -3 \" ++ ( String . fromInt <| scale * 80 + 4 ) ++ \" \" ++ ( String . fromInt <| scale * 50 + 24 ))] [ g [] [ rect [ x \"0\" , y \"0\" , width ( String . fromInt ( scale * 80 )) , height ( String . fromInt ( scale * 50 )) , rx ( String . fromInt <| scale ) , ry ( String . fromInt <| scale ) , id \"box\" ] []] , g [ blurAtPause ] ( concat ( toList ( indexedMap ( \\ y rows -> ( concat ( toList ( indexedMap ( \\ x cell -> viewCell ( x , y ) cell ) rows )))) grid ))) , g [ blurAtPause ] [ viewHero actors . player , viewSnitch actors . snitch ] , ( viewOverlay state ) , ( viewSnitchBar snitchTime ) ] view : Model -> Html Msg view model = main_ [] [ div [ id \"header\" ] [ text \" \\\\ \\\\ S L A S H E R / /\" ] , div [ id \"arena\" ] [ viewArena model ] , div [ id \"help\" ] [ text \"keys: Left \\\\ | Right / | Space pause\" ] , div [ id \"footer\" ] [ text \"Use the source, at \" , a [ href \"https://entangled.github.io/\" ] [ text \"Entangled!\" ] ] ] Completing the game \u00b6 From the code we can either build a HTML or a JavaScript file for embedding. We will manually create the HTML so that we can also create a stylesheet. Here's the Makefile for creating an optimized and uglified version of slasher (you can install uglifyjs with npm install -g uglify-js ): .PHONY : build build : slasher . min . js slasher.js : src / Main . elm elm make src/Main.elm --output = slasher.js --optimize slasher.min.js : slasher . js uglifyjs slasher.js --compress 'pure_funcs=\"F2,F3,F4,F5,F6,F7,F8,F9,A2,A3,A4,A5,A6,A7,A8,A9\",pure_getters,keep_fargs=false,unsafe_comps,unsafe' | uglifyjs --mangle --output = slasher.min.js The HTML can be very short now: <!DOCTYPE html> < html > < head > < title > Slasher </ title > < meta charset = \"UTF-8\" > < < google-font > > < link rel = \"stylesheet\" href = \"css/slasher.css\" > </ head > < body > < div id = \"slasher\" ></ div > < script src = \"js/slasher.min.js\" ></ script > < script > Elm . Main . init ({ node : document . getElementById ( \"slasher\" ) }); </ script > </ body > </ html > Browse Google fonts for a nice slashery font: < link href = \"https://fonts.googleapis.com/css?family=Love+Ya+Like+A+Sister\" rel = \"stylesheet\" > And add some style body { font-family : \"Love Ya Like A Sister\" , sans serif ; background-image : radial-gradient ( circle , #112233 , #000033 ); color : white ; } # arena svg { max-height : 80 vh ; } # header { font-size : 20 pt ; text-align : center ; margin-bottom : 5 pt ; } # help { text-align : center ; } # footer { font-family : sans serif ; font-size : 8 pt ; background : #ffffff 44 ; color : black ; text-align : center ; padding : 4 pt 0 ; margin : 10 pt 0 0 0 ; border-radius : 5 pt ; } # footer a { color : #202 ; } . blurred { filter : blur ( 1 pt ); } /* svg #overlay { filter: blur(1pt); } */ svg # overlay rect { opacity : 0.3 ; fill : black ; } svg # overlay text { font-size : 70 pt ; fill : white ; } svg # box { opacity : 0.5 ; stroke : goldenrod ; stroke-width : 2 pt ; fill : none ; } svg line . slash { stroke : #8888ff ; stroke-width : 2 pt ; } svg . hero { fill : red ; stroke : black ; } svg . snitch { fill : gold ; stroke : black ; } svg # snitch-bar { opacity : 0.8 ; fill : gold ; stroke : black ; }","title":"Slasher"},{"location":"slasher/#main","text":"Elm has a set of different application formats, depending on the level of interactivity that is needed: sandbox : has no interaction with outside world, except through buttons, text fields and forms. element : can talk to HTTP, use random numbers, and capture browser events. document : similar to element, but generates the entire document. application : also handles URL requests and URL changes. The Elm guide has a section describing the difference between sandbox and element . The event loop of element looks like this: {#fig:elm-event-loop} We will be creating an element program, compile it to a JavaScript file, and create a HTML and CSS around it by hand. The lay-out of such a program in Elm looks as follows: module Main exposing (..) << imports >> << main >> << model >> << update >> << subscriptions >> << view >> The main function tells Elm that we create an element main main = Browser . element { init = init , update = update , subscriptions = subscriptions , view = view } The rest of the program has: model : Data model of the game. In strongly typed functional languages the design of a program always starts with thinking about type definitions. update : Defines how to propagate the model from one state to the next. subscriptions : Subscriptions to external events, that is, events that cannot be bound to an action on a HTML element. view : Describes how to translate the model state into an HTML element.","title":"Main"},{"location":"slasher/#imports","text":"imports import Browser import Array exposing ( Array , repeat , indexedMap , toList , set , get ) import List exposing ( concat ) import Browser.Events exposing ( onAnimationFrameDelta , onKeyDown ) import Html exposing ( Html , button , div , text , p , input , main_ , a ) import Html.Attributes exposing ( href ) import Html.Events exposing ( onClick , preventDefaultOn ) import Svg exposing ( svg , circle , line , rect , g , polygon , text_ ) import Svg.Attributes exposing (..) import Random import Json.Decode as Decode","title":"Imports"},{"location":"slasher/#the-model","text":"The model will be a grid of cells and two actors: our hero and the snitch (if you like to play around with the code, try to add a list of enemy actors that can hurt the hero). type alias Model = { actors : { player : Actor , snitch : Actor } , grid : Grid , snitchTime : Float , state : GameState } In addition to the actors and the grid , we have to keep time, and a game state flag. The game state tells us if the game is running etc. type GameState = Start | Running | Pause | Won We define the grid as nested arrays of cells, where each cell can have the value Empty , Slash or BackSlash : type alias Grid = Array ( Array Cell ) type Cell = Empty | Slash | BackSlash gridRef : ( Int , Int ) -> Grid -> Cell gridRef ( i , j ) grid = Maybe . withDefault Empty <| Maybe . andThen ( \\ row -> get i row ) ( get j grid ) gridSet : ( Int , Int ) -> Cell -> Grid -> Grid gridSet ( i , j ) cell grid = let row_ = get j grid in case row_ of Nothing -> grid Just row -> set j ( set i cell row ) grid Lastly, an Actor is something that has a location and a velocity, each a 2-tuple of floats. type alias Actor = { location : ( Float , Float ) , velocity : ( Float , Float ) }","title":"The Model"},{"location":"slasher/#config","text":"type alias Config = { gridSize : ( Int , Int ) , playerSpeed : Float , scale : Int , snitchTime : Float } config : Config config = { gridSize = ( 80 , 50 ) , playerSpeed = 0. 03 , scale = 15 , snitchTime = 10000 } inRange : ( Int , Int ) -> Bool inRange ( i , j ) = let ( w , h ) = config . gridSize in i >= 0 && i < w && j >= 0 && j < h","title":"Config"},{"location":"slasher/#init","text":"The model is initialised by the init function. This function has the funny signature () -> (Model, Cmd Msg) . We'll return to the type definition of Msg later, but what this means is that the init function generates an initial state and a command (or list of commands) that tells the Elm run-time to perform an action upon initialisation. Such an action can be anything that requires some form of external state: HTTP requests, location/time information, and in our case: generating random numbers. init : () -> ( Model , Cmd Msg ) init _ = let ( width , height ) = config . gridSize playerLoc = (( toFloat width ) / 2 + 0. 5 , 2. 5 ) in ( { actors = { player = { location = playerLoc , velocity = ( 0. 0 , config . playerSpeed ) } , snitch = { location = ( 0. 0 , 0. 0 ) , velocity = ( 0. 0 , 0. 0 ) } } , grid = makeGrid config . gridSize , snitchTime = 0. 0 , state = Start }, Random . generate PlaceSnitch ( Random . pair ( Random . int 0 ( width - 1 )) ( Random . int 0 ( height - 1 )))) makeGrid : ( Int , Int ) -> Array ( Array Cell ) makeGrid ( width , height ) = Array . repeat height ( Array . repeat width Empty )","title":"Init"},{"location":"slasher/#subscriptions","text":"keyDecoder : Decode . Decoder Msg keyDecoder = Decode . map KeyPress ( Decode . field \"key\" Decode . string ) subscriptions : Model -> Sub Msg subscriptions model = Sub . batch [ onAnimationFrameDelta TimeStep , onKeyDown keyDecoder ]","title":"Subscriptions"},{"location":"slasher/#update","text":"The update function has the following signature: update : Msg -> Model -> ( Model , Cmd Msg ) This means that, given a message and a model state, we can generate a new model state and a list of requests to the Elm run-time. This list of requests has the type Cmd Msg , telling Elm that, whatever the request, it has to respond with a Msg . type Msg = KeyPress String | TimeStep Float | PlaceSnitch ( Int , Int ) In our case, a message is either a KeyPress indicating a key being pressed, a TimeStep when a new animation frame is triggered or a PlaceSnitch when the random number generator returns a fresh pair of coordinates. We'll defer the handling of these messages to helper functions. update msg model = case msg of TimeStep dt -> let next = timeStep dt model in ( next , checkSnitchTime next ) KeyPress k -> ( keyMap k model , Cmd . none ) PlaceSnitch l -> ( placeSnitch l model , Cmd . none ) << msg - type >> << update - function >>","title":"Update"},{"location":"slasher/#time-step","text":"Each time step, if the game in in Running state, we need to check if the game is won, and otherwise move all actors that need moving. timeStep : Float -> Model -> Model timeStep dt ({ actors , grid , snitchTime , state } as model ) = case state of Running -> if didWeWin model then { model | state = Won } else { model | snitchTime = snitchTime - dt , actors = { actors | player = updateActor grid dt actors . player } } _ -> model","title":"Time step"},{"location":"slasher/#did-we-win","text":"didWeWin : Model -> Bool didWeWin ({ actors } as model ) = activeCell actors . snitch == activeCell actors . player","title":"Did we win?"},{"location":"slasher/#update-actors","text":"Updating an actor is a bit of boring bookkeeping. We check whether the actor's active grid cell changes. This happens when the actor moves across the center of a cell. If the active cell changed, potentially the actor bounced off a (back)slash or a wall. updateActor : Grid -> Float -> Actor -> Actor updateActor grid dt actor = let a = activeCell actor b = activeCell <| moveActor dt actor in if a /= b then case ( gridRef a grid ) of Slash -> bounceActor dt Slash actor BackSlash -> bounceActor dt BackSlash actor Empty -> if inRange b then moveActor dt actor else bounceOffWall dt actor else moveActor dt actor","title":"Update actors"},{"location":"slasher/#active-cell","text":"To get a smooth flying experience the actors have floating point coordinates. From the coordinates we need to compute the integer indices into the grid. activeCell : Actor -> ( Int , Int ) activeCell actor = let ( x , y ) = actor . location in case ( actorDirection actor ) of East -> ( round x , floor y ) West -> ( round ( x - 1. 0 ), floor y ) North -> ( floor x , round ( y - 1. 0 )) South -> ( floor x , round y )","title":"Active cell"},{"location":"slasher/#direction","text":"From the velocity we often need to know in which of the four cardinal directions an actor is moving. type Direction = North | East | South | West actorDirection : Actor -> Direction actorDirection actor = let ( vx , vy ) = actor . velocity in if ( abs vx ) > ( abs vy ) then if vx > 0 then East else West else if vy > 0 then South else North","title":"Direction"},{"location":"slasher/#actor-dynamics","text":"When an actor moves, it may do so in one of three ways: move without obstacle bounce off a (back)slash) bounce off the wall For each of these cases we have a separate function. moveActor : Float -> Actor -> Actor moveActor dt actor = let ( x , y ) = actor . location ( vx , vy ) = actor . velocity in { actor | location = ( x + dt * vx , y + dt * vy ) } bounceActor : Float -> Cell -> Actor -> Actor bounceActor dt cell actor = let ( i , j ) = activeCell actor ( vx , vy ) = actor . velocity newloc = (( toFloat i ) + 0. 5 , ( toFloat j ) + 0. 5 ) in case cell of Slash -> moveActor dt { location = newloc , velocity = ( - vy , - vx ) } BackSlash -> moveActor dt { location = newloc , velocity = ( vy , vx ) } Empty -> actor bounceOffWall : Float -> Actor -> Actor bounceOffWall dt actor = let ( x , y ) = actor . location ( vx , vy ) = actor . velocity newloc = case actorDirection actor of North -> ( x , 0. 0 ) South -> ( x , 50. 0 ) East -> ( 80. 0 , y ) West -> ( 0. 0 , y ) in moveActor dt { location = newloc , velocity = ( - vx , - vy ) }","title":"Actor dynamics"},{"location":"slasher/#snitch-time","text":"Each time step we decreased the snitchTime field. If it drops below 0, we ask the Elm runtime for a new random snitch location. checkSnitchTime : Model -> Cmd Msg checkSnitchTime { snitchTime } = let ( w , h ) = config . gridSize in if snitchTime < 0. 0 then Random . generate PlaceSnitch ( Random . pair ( Random . int 0 ( w - 1 )) ( Random . int 0 ( h - 1 ))) else Cmd . none","title":"Snitch time"},{"location":"slasher/#moving-the-snitch","text":"When the snitch is placed we reset the snitchTime to the configured value placeSnitch : ( Int , Int ) -> Model -> Model placeSnitch ( x , y ) ({ actors } as model ) = { model | snitchTime = config . snitchTime , actors = { actors | snitch = { location = (( toFloat x ) + 0. 5 , ( toFloat y ) + 0. 5 ) , velocity = ( 0. 0 , 0. 0 ) } } }","title":"Moving the snitch"},{"location":"slasher/#keymap","text":"We listen to three keys: space, left arrow and right arrow. We could have listened for \\ and / keys, but in Firefox the / key also activates quick search. We could work around this, but it is a bit of a hassle. keyMap : String -> Model -> Model keyMap k ({ state } as model ) = let slash cell = if state == Running then place cell model else model in case k of \" \" -> let newState = case state of Running -> Pause Start -> Running Pause -> Running Won -> Won in { model | state = newState } \"ArrowLeft\" -> slash BackSlash \"ArrowRight\" -> slash Slash _ -> model","title":"Keymap"},{"location":"slasher/#placing-a-backslash","text":"place : Cell -> Model -> Model place cell ({ actors , grid } as model ) = let loc = activeCell actors . player in { model | grid = gridSet loc cell grid }","title":"Placing a (back)slash"},{"location":"slasher/#view","text":"scale : Int scale = config . scale fScale : Float fScale = toFloat scale viewCell : ( Int , Int ) -> Cell -> List ( Html Msg ) viewCell ( i , j ) c = case c of Slash -> [ line [ x1 ( String . fromInt ( scale * i + scale )) , y1 ( String . fromInt ( scale * j )) , x2 ( String . fromInt ( scale * i )) , y2 ( String . fromInt ( scale * j + scale )) , class \"slash\" ] [] ] BackSlash -> [ line [ x1 ( String . fromInt ( scale * i )) , y1 ( String . fromInt ( scale * j )) , x2 ( String . fromInt ( scale * i + scale )) , y2 ( String . fromInt ( scale * j + scale )) , class \"slash\" ] [] ] Empty -> [] formatPath : List ( Float , Float ) -> String formatPath pts = case pts of [] -> \"\" ( x , y ) :: rest -> ( String . fromFloat <| x * fScale ) ++ \",\" ++ ( String . fromFloat <| y * fScale ) ++ \" \" ++ formatPath rest viewHero : Actor -> Html Msg viewHero actor = let ( x , y ) = actor . location path = case actorDirection actor of South -> [ ( x , y ) , ( x + 0. 3 , y - 1 ) , ( x - 0. 3 , y - 1 ) ] North -> [ ( x , y ) , ( x + 0. 3 , y + 1 ) , ( x - 0. 3 , y + 1 ) ] West -> [ ( x , y ) , ( x + 1 , y + 0. 3 ) , ( x + 1 , y - 0. 3 ) ] East -> [ ( x , y ) , ( x - 1 , y + 0. 3 ) , ( x - 1 , y - 0. 3 ) ] in polygon [ points <| formatPath path , class \"hero\" ] [] viewSnitch : Actor -> Html Msg viewSnitch actor = let ( x , y ) = actor . location in circle [ cx ( String . fromFloat <| x * fScale ) , cy ( String . fromFloat <| y * fScale ) , r ( String . fromInt <| scale // 2 ) , class \"snitch\" ] [] viewOverlay : GameState -> Html Msg viewOverlay state = let ( w , h ) = config . gridSize sWidth = ( String . fromInt <| config . scale * w ) sHeight = ( String . fromInt <| config . scale * h ) middleX = ( String . fromInt <| config . scale * w // 2 ) middleY = ( String . fromInt <| config . scale * h // 2 ) rectA = rect [ x \"0\" , y \"0\" , width sWidth , height sHeight , rx ( String . fromInt <| scale ) , ry ( String . fromInt <| scale ) , style \"fill: black\" ] [] textA s = text_ [ x middleX , y middleY , textAnchor \"middle\" ] [ text s ] overlay s = g [ id \"overlay\" ] [ rectA , textA s ] in case state of Running -> g [] [] Won -> overlay \"YOU WIN!\" Start -> overlay \"press space to start\" Pause -> overlay \"PAUSE\" viewSnitchBar : Float -> Html Msg viewSnitchBar t = let u = t / config . snitchTime ( w , h ) = config . gridSize sWidth = String . fromFloat <| ( toFloat w ) * u * ( toFloat config . scale ) in rect [ x \"0\" , y ( String . fromInt <| h * config . scale + 10 ) , width sWidth , height ( String . fromInt <| config . scale // 2 ) , id \"snitch-bar\" ] [] viewArena : Model -> Html Msg viewArena ({ actors , grid , state , snitchTime } as model ) = let blurAtPause = class <| if state == Running then \"non-blurred\" else \"blurred\" in svg [ width \"100%\" , viewBox ( \"-3 -3 \" ++ ( String . fromInt <| scale * 80 + 4 ) ++ \" \" ++ ( String . fromInt <| scale * 50 + 24 ))] [ g [] [ rect [ x \"0\" , y \"0\" , width ( String . fromInt ( scale * 80 )) , height ( String . fromInt ( scale * 50 )) , rx ( String . fromInt <| scale ) , ry ( String . fromInt <| scale ) , id \"box\" ] []] , g [ blurAtPause ] ( concat ( toList ( indexedMap ( \\ y rows -> ( concat ( toList ( indexedMap ( \\ x cell -> viewCell ( x , y ) cell ) rows )))) grid ))) , g [ blurAtPause ] [ viewHero actors . player , viewSnitch actors . snitch ] , ( viewOverlay state ) , ( viewSnitchBar snitchTime ) ] view : Model -> Html Msg view model = main_ [] [ div [ id \"header\" ] [ text \" \\\\ \\\\ S L A S H E R / /\" ] , div [ id \"arena\" ] [ viewArena model ] , div [ id \"help\" ] [ text \"keys: Left \\\\ | Right / | Space pause\" ] , div [ id \"footer\" ] [ text \"Use the source, at \" , a [ href \"https://entangled.github.io/\" ] [ text \"Entangled!\" ] ] ]","title":"View"},{"location":"slasher/#completing-the-game","text":"From the code we can either build a HTML or a JavaScript file for embedding. We will manually create the HTML so that we can also create a stylesheet. Here's the Makefile for creating an optimized and uglified version of slasher (you can install uglifyjs with npm install -g uglify-js ): .PHONY : build build : slasher . min . js slasher.js : src / Main . elm elm make src/Main.elm --output = slasher.js --optimize slasher.min.js : slasher . js uglifyjs slasher.js --compress 'pure_funcs=\"F2,F3,F4,F5,F6,F7,F8,F9,A2,A3,A4,A5,A6,A7,A8,A9\",pure_getters,keep_fargs=false,unsafe_comps,unsafe' | uglifyjs --mangle --output = slasher.min.js The HTML can be very short now: <!DOCTYPE html> < html > < head > < title > Slasher </ title > < meta charset = \"UTF-8\" > < < google-font > > < link rel = \"stylesheet\" href = \"css/slasher.css\" > </ head > < body > < div id = \"slasher\" ></ div > < script src = \"js/slasher.min.js\" ></ script > < script > Elm . Main . init ({ node : document . getElementById ( \"slasher\" ) }); </ script > </ body > </ html > Browse Google fonts for a nice slashery font: < link href = \"https://fonts.googleapis.com/css?family=Love+Ya+Like+A+Sister\" rel = \"stylesheet\" > And add some style body { font-family : \"Love Ya Like A Sister\" , sans serif ; background-image : radial-gradient ( circle , #112233 , #000033 ); color : white ; } # arena svg { max-height : 80 vh ; } # header { font-size : 20 pt ; text-align : center ; margin-bottom : 5 pt ; } # help { text-align : center ; } # footer { font-family : sans serif ; font-size : 8 pt ; background : #ffffff 44 ; color : black ; text-align : center ; padding : 4 pt 0 ; margin : 10 pt 0 0 0 ; border-radius : 5 pt ; } # footer a { color : #202 ; } . blurred { filter : blur ( 1 pt ); } /* svg #overlay { filter: blur(1pt); } */ svg # overlay rect { opacity : 0.3 ; fill : black ; } svg # overlay text { font-size : 70 pt ; fill : white ; } svg # box { opacity : 0.5 ; stroke : goldenrod ; stroke-width : 2 pt ; fill : none ; } svg line . slash { stroke : #8888ff ; stroke-width : 2 pt ; } svg . hero { fill : red ; stroke : black ; } svg . snitch { fill : gold ; stroke : black ; } svg # snitch-bar { opacity : 0.8 ; fill : gold ; stroke : black ; }","title":"Completing the game"},{"location":"syntax_experiments/","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. code example entangled syntax \u00b6 spacedSyntax let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" } code example braces syntax \u00b6 spacedSyntax let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" } Code example space syntax with title so \u00b6 must support code highlighthing id and title file://thisShouldBreak.py let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" } Code example space syntax \u00b6 must support code highlighthing id and title haskell file=\"this should break.py\" title=\"spacedSyntax\" let syntax : entangled.Syntax = { matchCodeStart = \"^[ ]* [[:alpha:]]+\" , matchCodeEnd = \"^[ ] \" , extractLanguage = \" ([[:alpha:]]+)\" , extractReferenceName = \" [[:alpha:]]+[ ]+.*id=\\\"([^\\\"]*)\\\".*\" , extractFileName = \" [[:alpha:]]+[ ]+. file=\\\"([^\\\"] )\\\". \" } ```","title":"Experiments"},{"location":"syntax_experiments/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"syntax_experiments/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"syntax_experiments/#code-example-entangled-syntax","text":"spacedSyntax let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" }","title":"code example entangled syntax"},{"location":"syntax_experiments/#code-example-braces-syntax","text":"spacedSyntax let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" }","title":"code example braces syntax"},{"location":"syntax_experiments/#code-example-space-syntax-with-title-so","text":"must support code highlighthing id and title file://thisShouldBreak.py let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" }","title":"Code example space syntax with title so"},{"location":"syntax_experiments/#code-example-space-syntax","text":"must support code highlighthing id and title haskell file=\"this should break.py\" title=\"spacedSyntax\" let syntax : entangled.Syntax = { matchCodeStart = \"^[ ]* [[:alpha:]]+\" , matchCodeEnd = \"^[ ] \" , extractLanguage = \" ([[:alpha:]]+)\" , extractReferenceName = \" [[:alpha:]]+[ ]+.*id=\\\"([^\\\"]*)\\\".*\" , extractFileName = \" [[:alpha:]]+[ ]+. file=\\\"([^\\\"] )\\\". \" } ```","title":"Code example space syntax"}]}